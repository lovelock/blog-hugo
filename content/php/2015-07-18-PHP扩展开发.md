+++
title  = "PHP扩展开发第一步 —— 创建一个可工作的方法"
date = "2015-07-18T21:23:29"
+++


这个问题困扰我已经很久了，但总是没有心情坐下来好好的研究一下，今天终于厘清了一点头绪，记录下来，留给像我一样对网络上的教程的理解能力没有那么好的同学。

我不想像那些正常的教程一样，先讲一番PHP的声明周期，来先看一下正反馈吧。请跟我一步一步来，让你先看到你的扩展可以工作。相关代码请查看[https://github.com/lovelock/php_ext_example.git](https://github.com/lovelock/php_ext_example.git)。

以鸟哥的[用C/C++扩展你的PHP](http://www.laruence.com/2009/04/28/719.html)这篇文章中的例子作为我们的目标吧，简单的打印一个Hello World也没什么意思。

首先看PHP版本的代码：

```php
// PHP版本的self_concat函数
function self_concat($str, $n)
{
	$result = "";
	for ($i = 0; $i < $n; $i++) {
		$result .= $str;
	}

	return $result;
}
```

那么再来想如果我们写了一个PHP扩展，来实现这个功能，它替代了什么？

对，我们本来用PHP写的逻辑现在放在了扩展里面用C实现了。这样的结果就是我们可以省掉上面PHP版本的self_concat函数的定义，在需要这个函数的地方直接调用就好了。

具体的步骤如下：

1. 先给扩展取个名字吧，以`php_ext_example`为例

2. 声明函数原型，就像C/C++中头文件中函数的声明一样，写在一个单独的文件中，声明了**返回值**、**函数名**、**函数签名**，注意**没有分号**。至于文件的后缀，貌似没有特别的要求，鸟哥用了`def`，看到有其他博客作者用了`proto`，本质是一样的。

	```c
	string self_concat(string str, int n)
	```

3. 执行`ext`目录内的`ext_skel`命令，顾名思义，这个命令的作用就是为扩展开发者搭建起一套骨架，让我们在上面方便的进行自己的创作。这里我们需要加入两个参数，`—extname`和`—proto`。

	`./ext_skel —extname=php_ext_example —proto=php_ext_example.proto`

	执行完这个命令就能在`ext`目录下看到`php_ext_example`目录了。打开里面发现一堆文件。

4. 首先需要修改`config.m4`文件，找到

	```m4
	dnl PHP_ARG_WITH(php_ext_example, for php_ext_example support,
	dnl Make sure that the comment is aligned:
	dnl [  --with-php_ext_example   Include php_ext_example support])
	```

	要知道`dnl`是注释的意思，先把这几行的注释去掉，也就是让它生效。得到

	```m4
	PHP_ARG_WITH(php_ext_example, for php_ext_example support,
	Make sure that the comment is aligned:
	[  --with-php_ext_example             Include php_ext_example support])
	```

	它的意思是把`--with-php_ext_example`这个选项加入到`configure`的选项中去。

5. 修改`php_ext_example.c`，重头戏来了，前面做的都是为这个做准备。找到`PHP_FUNCTION(self_concat)`这一行，这是函数的实现。先甭管为什么把这段代码敲进去。

	```c
	PHP_FUNCTION(self_concat)
	{
	    char *str = NULL;
	    int argc = ZEND_NUM_ARGS();
	    int str_len;
	    long n;
	    char *result;
	    char *ptr;
	    int result_length;
	
	    if (zend_parse_parameters(argc TSRMLS_CC, "sl", &str, &str_len, &n) == FAILURE)
	        return;
	
	    result_length = (str_len * n);
	    result = (char *) emalloc(result_length + 1);
	    ptr = result;
	
	    while (n--) {
	        memcpy(ptr, str, str_len);
	        ptr += str_len;
	    }
	
	    ptr = '\0';
	    RETURN_STRINGL(result, result_length, 0);
	}
	```

OK，这个时候一个具有“重复打印字符串”功能的扩展就写好了。怎么证明它是能工作的呢？别着急，先把它编译进PHP吧。
还记得执行完`ext_skel`之后弹出的一段说明吗？

```
$ cd ..
$ vi ext/php_ext_example/config.m4
$ ./buildconf
$ ./configure --[with|enable]-php_ext_example
$ make
$ ./sapi/cli/php -f ext/php_ext_example/php_ext_example.php
$ vi ext/php_ext_example/php_ext_example.c
$ make
```

现在我们需要执行从3-6,观察一下输出吧。第3步你会看到这个提示

```
You should not run buildconf in a release package.
use buildconf --force to override this check.
```

按它说的，加上`--force`即可。
第6步如果你能看到

```
php-5.6.11  sapi/cli/php ext/php_ext_example/php_ext_example.php
Functions available in the test extension:
confirm_php_ext_example_compiled
Congratulations! You have successfully modified ext/php_ext_example/config.m4. Module php_ext_example is now compiled into PHP.
```

那么恭喜你，你的第一个PHP扩展已经编译进PHP了。等等，这有什么用呢？我怎么知道它能不能工作呢？
那就写一个脚本试试吧。

```php
echo self_concat("HappyHacker", 3);
echo "\n";
echo self_concat("Lovelock", 1);
```

执行脚本，有没有很神奇？

好了，繁华落尽，毕竟还是要回归到技术的本质上来。
请看[PHP扩展开发第二步]()。
