+++
title  = "PHP扩展开发第二步 —— 定义方法"
date = "2015-07-19T11:39:39"
+++

上一节展示了如何一步一步的创建一个包含一个全局方法的扩展。现在来了解一下这个扩展是怎么生效的。

首先要知道`ext_skel`到底为我们做了什么，就我们的这个例子中`string self_concat(string str, int n)`而言

    1. 创建一个函数原型，包括边界条件的检查等
    2. 添加函数入口

具体到代码中也就是增加了这两部分。
对应第一条：

```c
/* {{{ proto string self_concat(string str, int n) */
PHP_FUNCTION(self_concat)
{
    char *str = NULL;
    int argc = ZEND_NUM_ARGS();
    int str_len;
    long n;
     
    if (zend_parse_parameters(argc TSRMLS_CC, "sl", &str, &str_len, &n) == FAILURE)
        return;
     
    php_error(E_WARNING, "self_concat: not yet implemented"); 
}
 
/* }}} */
```

对应第二条

```c
/* {{{ myfunctions_functions[]
 *
 * Every user visible function must have an entry in myfunctions_functions[].
 */
 const zend_function_entry myfunctions_functions[] = {
	 PHP_FE(confirm_myfunctions_compiled,    NULL)       /* For testing, remove later. */
     PHP_FE(self_concat, NULL)
     PHP_FE_END  /* Must be the last line in myfunctions_functions[] */
};
/* }}} */
```
> 里面的`PHP_FE`就是`Function Entry`的意思，在后面会见到`PHP_ME`也就是`Method Entry`的意思，后者指的是类中方法的入口。

我们的这个方法是接受参数的，所以也要有内部的方法来进行相关的处理，比如参数的个数判断了，参数的类型转换之类的，这些处理都是由函数
`zend_parse_parameters(int num_args TSRMLS_DC, char *type_spec, …);`
代劳的。

{% blockquote Laruence http://www.laruence.com/2009/04/28/719.html 用C/C++扩展你的PHP %}
第一个参数是传递给函数的参数个数。通常的做法是传给它ZEND_NUM_ARGS()。这是一个表示传递给函数参数总个数的宏。第二个参数是为了线程安全，总是传递TSRMLS_CC宏，后面会讲到。第三个参数是一个字符串，指定了函数期望的参数类型，后面紧跟着需要随参数值更新的变量列表。因为PHP采用松散的变量定义和动态的类型判断，这样做就使得把不同类型的参数转化为期望的类型成为可能。例如，如果用户传递一个整数变量，可函数需要一个浮点数，那么zend_parse_parameters()就会自动地把整数转换为相应的浮点数。如果实际值无法转换成期望类型（比如整形到数组形），会触发一个警告。

下表列出了可能指定的类型。我们从完整性考虑也列出了一些没有讨论到的类型。

+++

类型指定符	| 对应的C类型	| 描述
---|---|---
l	| long	| 符号整数
d	| double	|浮点数
s	| char *, | int	二进制字符串，长度
b	| zend_bool	| 逻辑型（1或0）
r	| zval *	| 资源（文件指针，数据库连接等）
a	| zval *	| 联合数组
o	| zval *	| 任何类型的对象
O	| zval *	| 指定类型的对象。需要提供目标对象的类类型
z	| zval *	| 无任何操作的zval
+++


为了容易地理解最后几个选项的含义，你需要知道zval是Zend引擎的值容器[1]。无论这个变量是布尔型，字符串型或者其他任何类型，其信息总会包含在一个zval联合体中。本章中我们不直接存取zval，而是通过一些附加的宏来操作。下面的是或多或少在C中的zval, 以便我们能更好地理解接下来的代码。

```c
typedef union _zval{
     long lval;
     double dval;
     struct {
          char *val;
          int len;
     }str;
 
     HashTable *ht;
     zend_object_value obj;
 
}zval;
```

在我们的例子中，我们用基本类型调用`zend_parse_parameters()`，以本地C类型的方式取得函数参数的值，而不是用`zval`容器。

为了让`zend_parse_parameters()`能够改变传递给它的参数的值，并返回这个改变值，需要传递一个引用。仔细查看一下`self_concat()`：

```c
if (zend_parse_parameters(argc TSRMLS_CC, "sl", &str, &str_len, &n) == FAILURE)
    return;
```

注意到自动生成的代码会检测函数的返回值`FAILUER`(成功即`SUCCESS`)来判断是否成功。如果没有成功则立即返回，并且由`zend_parse_parameters()`负责触发警告信息。因为函数打算接收一个字符串`l`和一个整数`n`，所以指定 `”sl”` 作为其类型指示符。

    - `s`需要两个参数，所以我们传递参考`char * 和 int (str 和 str_len)`给`zend_parse_parameters()`函数。无论什么时候，记得总是在代码中使用字符串长度`str_len`来确保函数工作在二进制安全的环境中。不要使用`strlen()`和`strcpy()`，除非你不介意函数在二进制字符串下不能工作。二进制字符串是包含有`nulls`的字符串。二进制格式包括图象文件，压缩文件，可执行文件和更多的其他文件。
    - `l`只需要一个参数，所以我们传递给它`n`的引用。尽管为了清晰起见，骨架脚本生成的C变量名与在函数原型定义文件中的参数名一样；这样做不是必须的，尽管在实践中鼓励这样做。

回到转换规则中来。下面三个对`self_concat()`函数的调用使`str, str_len和n`得到同样的值：

```php
self_concat("321", 5);
self_concat(321, "5");
self_concat("321", "5");
str points to the string "321", str_len equals 3, and n equals 5.
str 指向字符串"321"，str_len等于3，n等于5。
```
{% endblockquote %}

> 上面这段内容有关Zend引擎，我一窍不通，不敢瞎说，只好把原文引用过来了。

## 内存管理

用于从堆中分配内存的PHP API几乎和标准C API一样，在编写扩展的时候，应该使用PHP API而不是C API函数。

```c
emalloc(size_t size);
efree(void *ptr);
ecalloc(size_t nmemb, size_t size);
erealloc(void *ptr, size_t size);
estrdup(const char *s);
estrndup(const char *s, unsigned int length);
```

这些函数的优点：

    1. 自动在页面请求的最后释放内存，避免内存泄露
    2. 多线程环境下的性能提升
    3. 调试模式下检测内存错误

## 从PHP函数中的返回值

扩展API包含丰富的用于从函数中返回值的宏。这些宏主要有两种风格：

    1. RETVAL_type()
    2. RETURN_type()

其中第一种用于在把控制交给脚本引擎前还需要做一些清理工作，然后再使用C的返回声明`return`返回到PHP；第二种使用更加普遍，它设置了返回类型，同事返回控制到PHP。

## 小结
这一篇涉及底层的东西较多，基本上是摘录了鸟哥翻译的`PHP5 Power Programming`的内容。有些深入的东西现在也不必理解，后面会慢慢的接触到。


