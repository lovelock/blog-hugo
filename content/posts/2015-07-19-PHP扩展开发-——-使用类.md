+++
title  = "PHP扩展开发第三步 —— 使用类"
date = "2015-07-19T12:48:46"
+++


既然用PHP编程，少不了需要用到类，前面我们说了如何定义一个全局可以用的方法，那么现在就来看看怎么创建一个类吧。

## 注册

前面提到在

```c
const zend_function_entry php_ext_example_functions[] = {
    PHP_FE(confirm_php_ext_example_compiled, NULL)
    PHP_FE(self_concat, NULL);
    PHP_FE_END
}
```

中注册了`PHP_FE`入口，从外部可以访问`self_concat`方法，新定义的类当然也要在这里注册来才能被访问了。比如新建的类叫做`SampleClass`。就需要把这段代码改成

```c
const zend_function_entry php_ext_example_functions[] = {
    PHP_ME(SampleClass, sayHello, NULL, ZEND_ACC_PUBLIC)
    PHP_FE(confirm_php_ext_example_compiled, NULL)
    PHP_FE(self_concat, NULL);
    PHP_FE_END
}
```

但在这之前需要先定义一个全局`zend_class_entry`，用于`zend_register_internal_class`。

```c
zend_class_entry *php_ext_example_class_entry;
```

在PHP扩展的生命周期中，扩展是在`Module Initialization`阶段初始化的，所以需要在`PHP_MINIT_FUNCTION`中注册类入口。

```c
PHP_MINIT_FUNCTION(php_ext_example)
{
    zend_class_entry tmp_ce;
    INIT_CLASS_ENTRY(tmp_ce, "SampleClass", php_ext_example_functions);
    php_ext_example_class_entry = zend_register_internal_class(&tmp_ce, TSRMLS_CC);
    return SUCCESS;
}
```

可以看到，在`PHP_MINIT_FUNCTION`中用到了`php_ext_sample_class_entry`和`php_ext_example_functions`，所以后两者应该放在前者的前面。

这样就很明了了，下一步就是实现`sayHello`方法了。
在上一节已经讲过了关于闯入参数的问题，这里不再赘述。值得注意的是，定义类的方法用的是`PHP_METHOD`宏，而不是定义全局方法的`PHP_FUNCTION`。

执行完`make`就可以通过
`sapi/cli/php --rc SampleClass`就可以看到这个类的结构了。

但这里我有一个疑问，那就是`self_concat`和`confirm_php_ext_example_compiled`方法其实并不是`SampleClass`类的方法，但不知道为什么成了类的成员方法。

## 属性和常量

例如类`SampleClass`拥有一个属性`foo`，那么相应的我们要给它定义`setter`和`getter`。
有了刚才的经验，添加两个方法一定是不在话下了。

但是虽然有了这两个方法，但变量`foo`现在还不是`SampleClass`的属性，所以在执行`getFoo()`方法的时候也不能确定这个变量是否存在，所以出于安全的考虑还是应该给类添加这个属性。同样是在MINIT阶段，使用`zend_declare_property_null`

```c
zend_declare_property_null(php_ext_example_class_entry, "foo", sizeof("foo") - 1, ZEND_ACC_PUBLIC TSRMLS_CC);
```

相应的，如果设置要给`foo`设置一个初始值，就要使用`zend_declare_property`的各种变种了，
见本系列博客的代码库。

同样，还有`zend_declare_class_constant_*`系列，用法和`zend_declare_property_*`类似。

## 继承和接口

和用户用PHP写的类一样，内部类也可以继承其他类或者实现接口。
举个最简单的例子，我们自定义一个异常类`CustomException`，继承自`Exception`。
同样，也可以定义一个接口。不过定义接口用的是`zend_register_internal_interface`。

```c
#include "zend_interfaces.h"

zend_class_entry *reversible_iterator_ce;

const zend_function_entry reversible_iterator_functions[] = {
    PHP_ABSTRACT_ME(ReversibleIterator, prev, arginfo_void)
    PHP_FE_END
};

PHP_MINIT_FUNCTION(test)
{
    zend_class_entry tmp_ce;
    INIT_CLASS_ENTRY(tmp_ce, "ReversibleIterator", reversible_iterator_functions);
    reversible_iterator_ce = zend_register_internal_interface(&tmp_ce TSRMLS_CC);

    /* ReversibleIterator extends Iterator. For interface inheritance the zend_class_implements()
     * function is used. */
    zend_class_implements(reversible_iterator_ce TSRMLS_CC, 1, zend_ce_iterator);

    return SUCCESS;
}
```




