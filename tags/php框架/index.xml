<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Php框架 on Me and the Web</title>
    <link>http://lovelock.github.io/tags/php%E6%A1%86%E6%9E%B6/</link>
    <description>Recent content in Php框架 on Me and the Web</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>frostwong@gmail.com (Frost Wong)</managingEditor>
    <webMaster>frostwong@gmail.com (Frost Wong)</webMaster>
    <copyright>(c) 2013-2015 Frost Wong. All rights reserved.</copyright>
    <lastBuildDate>Sun, 10 Jan 2016 22:02:07 +0800</lastBuildDate>
    <atom:link href="http://lovelock.github.io/tags/php%E6%A1%86%E6%9E%B6/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Symfony3学习第三章——创建第一个页面</title>
      <link>http://lovelock.github.io/symfony/Symfony3-03-create-your-first-page/</link>
      <pubDate>Sun, 10 Jan 2016 22:02:07 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://lovelock.github.io/symfony/Symfony3-03-create-your-first-page/</guid>
      <description>

&lt;p&gt;实际上前面我们已经看到了一个正常的页面了。是这样的
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-10%20%E4%B8%8B%E5%8D%8810.17.26.png&#34; alt=&#34;成功安装的Symfony3运行界面&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个默认的页面属于&lt;code&gt;AppBundle/Controller/DefaultController/indexAction&lt;/code&gt;，可以在该方法的annotation中找到对应的配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我不喜欢Annotation这种方式&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Annotation看起来是把路由信息和代码写在一起，增强了代码的可读性，但在我看来完全是没有必要的，因为这样我还需要在写代码的时候注意Annotaion的编写，一不小心写错了找都不好找。或者说，它增强了代码和配置的耦合。xml就不考虑了，那么冗长的写法谁受得了，幸亏没有提供JSON的支持——即便支持我也不用，JSON的可读性太差。所以YAML就成了我的首选。在本系列文章中，我都会用YAML方式做配置，包括但不限于路由控制、数据表设置等。&lt;/p&gt;

&lt;p&gt;不好的一点在于貌似官方还挺喜欢Annotaion，能下载到的Symfony Book、Symfony Cookbook都对YAML的介绍很少，默认都使用Annotation。然而这并不能阻挡我。&lt;/p&gt;

&lt;p&gt;废话了那么多，进入正题吧。&lt;/p&gt;

&lt;h2 id=&#34;配置文件的路径:eda8d5296735d13f3b5b849a706b5133&#34;&gt;配置文件的路径&lt;/h2&gt;

&lt;p&gt;路由的配置文件在&lt;code&gt;app/config/routing.yml&lt;/code&gt;，&lt;code&gt;resource&lt;/code&gt;行就指定了它要寻找的路由配置的位置，&lt;code&gt;type&lt;/code&gt;行指定了要查找的路由配置格式，默认是annotation。&lt;/p&gt;

&lt;p&gt;首先解释一下为什么会是&lt;code&gt;app/config/routing.yml&lt;/code&gt;，当然是因为&lt;/p&gt;

&lt;p&gt;```yaml framework:     #esi:             ~     #translator:      { fallbacks: [&amp;ldquo;%locale%&amp;rdquo;] }     secret:          &amp;ldquo;%secret%&amp;ldquo;     router:         resource: &amp;ldquo;%kernel.root_dir%/config/routing.yml&amp;rdquo;         strict_requirements: ~&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
那你还会问，`%kernel.root_dir`是在哪里配置的呢？问得好，这个设置可不在配置文件里，是在`Symfony\Component\HttpKernel\Kernel.php`中设定的，代码如下:

```php
protected function getKernelParameters()
    {
        $bundles = array();
        foreach ($this-&amp;gt;bundles as $name =&amp;gt; $bundle) {
            $bundles[$name] = get_class($bundle);
        }

        return array_merge(
            array(
                &#39;kernel.root_dir&#39; =&amp;gt; realpath($this-&amp;gt;rootDir) ?: $this-&amp;gt;rootDir,
                &#39;kernel.environment&#39; =&amp;gt; $this-&amp;gt;environment,
                &#39;kernel.debug&#39; =&amp;gt; $this-&amp;gt;debug,
                &#39;kernel.name&#39; =&amp;gt; $this-&amp;gt;name,
                &#39;kernel.cache_dir&#39; =&amp;gt; realpath($this-&amp;gt;getCacheDir()) ?: $this-&amp;gt;getCacheDir(),
                &#39;kernel.logs_dir&#39; =&amp;gt; realpath($this-&amp;gt;getLogDir()) ?: $this-&amp;gt;getLogDir(),
                &#39;kernel.bundles&#39; =&amp;gt; $bundles,
                &#39;kernel.charset&#39; =&amp;gt; $this-&amp;gt;getCharset(),
                &#39;kernel.container_class&#39; =&amp;gt; $this-&amp;gt;getContainerClass(),
            ),
            $this-&amp;gt;getEnvParameters()
        );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺着这个一步步的往下追，就可以查到每个kernel参数的来源了。&lt;/p&gt;

&lt;p&gt;刚才说到了路由配置，而且只想用yaml的格式，下面就改一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;app:
    resource: &amp;quot;@AppBundle/Resources/config/routing.yml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就表明会从&lt;code&gt;@AppBundle/Resources/config/routing.yml&amp;quot;&lt;/code&gt;中读取路由配置了。当然在下面也可以直接加上更多配置——经过我的一番实验，发现在这里是无法引入第二个路由配置文件的，改文件不支持&lt;code&gt;import&lt;/code&gt;，不支持多个&lt;code&gt;resource&lt;/code&gt;。。。&lt;/p&gt;

&lt;p&gt;注意，在&lt;code&gt;resource&lt;/code&gt;中的配置优先级是比当前文件下面的高的。和在同一个文件中的配置一样，因为路由信息一旦匹配成功就不再往下找了。&lt;/p&gt;

&lt;h2 id=&#34;路由规则:eda8d5296735d13f3b5b849a706b5133&#34;&gt;路由规则&lt;/h2&gt;

&lt;h3 id=&#34;简单路由规则:eda8d5296735d13f3b5b849a706b5133&#34;&gt;简单路由规则&lt;/h3&gt;

&lt;p&gt;一个最简化的可以执行的路由规则其实很简单，由path和defaults两部分构成。&lt;/p&gt;

&lt;p&gt;以下面的路由规则为例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# app/config/routing.yml
_welcome:
    path:      /
    defaults:  { _controller: AppBundle:Main:homepage }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;path是URI中的Path部分，完整的路径就是&lt;code&gt;http://symfony.dev/app_dev.php&lt;/code&gt;，它被映射到&lt;code&gt;AppBundle/MainController/homepageAction&lt;/code&gt;上。&lt;/p&gt;

&lt;h3 id=&#34;带占位符的路由规则:eda8d5296735d13f3b5b849a706b5133&#34;&gt;带占位符的路由规则&lt;/h3&gt;

&lt;p&gt;在RESTful的API设计中，是避免用query string的，相应的，用&lt;code&gt;/&lt;/code&gt;来分隔参数。我知道的有这样两种设计思路&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;带参数名 &lt;code&gt;/param1/value1/param2/value2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不带参数名 &lt;code&gt;/value1/value2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;很明显，第二种方式更简洁，因为程序肯定是知道第几个参数的意义是什么的，但这样客户端传递参数时就失去了灵活性。当然，在我看来，一个设计稳定的接口才重要，只要不随便改动，是没什么问题的。&lt;/p&gt;

&lt;p&gt;带占位符的路由规则&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;show:
    path:     /show/{title}
    defaults: { _controller: AppBundle:Article:show }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个路径会匹配所有/show/*，传进来的值会被当做参数&lt;code&gt;$title&lt;/code&gt;传递到方法&lt;code&gt;AppBundle\ArticleController\showAction&lt;/code&gt;中。例如，&lt;code&gt;/show/hello&lt;/code&gt;，那么在&lt;code&gt;AppBundle\ArticleController\showAction&lt;/code&gt;方法中拿到的&lt;code&gt;$title&lt;/code&gt;就是字符串&lt;code&gt;hello&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;可选占位符的路由规则:eda8d5296735d13f3b5b849a706b5133&#34;&gt;可选占位符的路由规则&lt;/h3&gt;

&lt;p&gt;上面介绍了带占位符的路由规则，那考虑这样一个场景，我像让&lt;code&gt;/show&lt;/code&gt;显示&lt;code&gt;$page=1&lt;/code&gt;的文章，而不需要指定&lt;code&gt;/show/1&lt;/code&gt;，如果加了&lt;code&gt;/show/{page}&lt;/code&gt;则按照给定的显示。可以类比PHP函数的默认参数，也很简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;page_show:
    path:     /show/{page}
    defaults: { _controller: AppBundle:Article:page, page: 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;参数要求:eda8d5296735d13f3b5b849a706b5133&#34;&gt;参数要求&lt;/h3&gt;

&lt;p&gt;上面两个例子会有冲突吗？当然会！比如&lt;code&gt;/show/2&lt;/code&gt;表示要展示第二页，那会不会是标题是2的文章呢？要怎么判断？&lt;/p&gt;

&lt;p&gt;可以看到，&lt;code&gt;show&lt;/code&gt;要求的参数是字符串，也就是文章的标题，而&lt;code&gt;page_show&lt;/code&gt;要求的参数是数字，也就是页数。所以可以用简单的正则表达式来做一下匹配。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;page_show:
    path:     /show/{page}
    defaults: { _controller: AppBundle:Article:page, page: 1 }
    requirements:
        page: \d+   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，所有匹配到数字的参数都会作为page，反之是title，就不会有任何冲突了。&lt;/p&gt;

&lt;h2 id=&#34;指定http-method:eda8d5296735d13f3b5b849a706b5133&#34;&gt;指定HTTP Method&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;contact_form:
    path:     /contact
    defaults: { _controller: AppBundle:Article:contact_form }
    methods: [GET, POST]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就要求只有用GET/POST方法，并且匹配到path才能完全匹配这条路由。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果没有指定方法，那任何方法都能匹配。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;指定host域名:eda8d5296735d13f3b5b849a706b5133&#34;&gt;指定HOST域名&lt;/h2&gt;

&lt;p&gt;假如你当前维护的一套代码运行在两个域名上，例如&lt;code&gt;m.example.com&lt;/code&gt;和&lt;code&gt;example.com&lt;/code&gt;，其中m开头的是只有移动端才会访问，这时要实现访问同一个path，但会route到不同的controller，就需要指定host域名了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;mobile_update:
    path:     /update
    host:     &amp;quot;m.example.com&amp;quot;
    defaults: { _controller: AppBundle:Article:mobile_update }

update:
    path:     /update
    host:     &amp;quot;example.com&amp;quot;
    defaults: { _controller: AppBundle:Article:update}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;host字段和path字段一样，支持placeholder，同时支持默认值和正则匹配。&lt;/p&gt;

&lt;h2 id=&#34;用-condition-完全自定义路由规则:eda8d5296735d13f3b5b849a706b5133&#34;&gt;用&lt;code&gt;condition&lt;/code&gt;完全自定义路由规则&lt;/h2&gt;

&lt;p&gt;使用The Expression Syntax component可以实现在YAML中用一种表达力很强的标记来实现高度自定义的路由规则。&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;update:
    path:     /update
    defaults: { _controller: AppBundle:Article:update}
    condition: &amp;quot;context.getMethod() in [&#39;GET&#39;, &#39;HEAD&#39;] and request.headers.get(&#39;User-Agent&#39;) matches &#39;/firefox/i&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样配置的路由规则就只允许Firefox浏览器访问了。&lt;/p&gt;

&lt;h2 id=&#34;生成url:eda8d5296735d13f3b5b849a706b5133&#34;&gt;生成URL&lt;/h2&gt;

&lt;p&gt;路由嘛，当然是双向的，一方面从URL到controller，一方面从controller到URL。前面讲的都是从URL到controller，那从controller回到URL应该怎么做呢？&lt;/p&gt;

&lt;p&gt;以&lt;code&gt;/show&lt;/code&gt;路径为例，可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$this-&amp;gt;get(&#39;router&#39;)-&amp;gt;generate(&#39;/show&#39;);
$this-&amp;gt;container-&amp;gt;get(&#39;router&#39;)-&amp;gt;generate(&#39;/show&#39;);
$this-&amp;gt;generateUrl(&#39;/show&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前两种方式其实是用到了Service Container，现在我对它的理解就是一个可以全局访问的类，由于要统一管理，所以就搞了个Container。一个系统中可以定义多个Service Container，但它如果不被访问时是不会创建的，而一旦创建，默认情况下就再次用它时返回的就还是之前的那个了，这就是所谓的共享型Service Container。而最后一种只不过是一种快捷方式了，本质上还是上面那样的实现。&lt;/p&gt;

&lt;p&gt;多说一点，上面三种方式生成的URL都一样，&lt;code&gt;/app_dev.php/show&lt;/code&gt;，但如果加上参数就不太一样了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;show:
    path:     /show/{id}
    defaults: { _controller: AppBundle:Article:show, id:20 }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;    $url = $this-&amp;gt;generateUrl(&#39;show&#39;,
            array(
                &#39;id&#39; =&amp;gt; 10,
                &#39;page&#39; =&amp;gt; 100,
            ));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出是&lt;code&gt;/app_dev.php/show/10?page=100&lt;/code&gt;，也就是说，如果在&lt;code&gt;generateUrl&lt;/code&gt;的第二个参数数组中出现了路由规则中没有定义的参数，该参数就会以query_string的形式存在了。&lt;/p&gt;

&lt;p&gt;要查看路由规则列表，可以用&lt;code&gt;bin/console debug:router&lt;/code&gt;。可不能小看这个console工具，以后的很多地方都要用到它呢。&lt;/p&gt;

&lt;p&gt;好了，现在基本上和路由相关的东西都介绍完了，如果想继续研究的话，就得看Route Component的文档了。&lt;/p&gt;

&lt;p&gt;看到这，读者应该会写第一个页面了吧？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Symfony3学习第二章——应用安装</title>
      <link>http://lovelock.github.io/symfony/symfony3-02-installation/</link>
      <pubDate>Sun, 10 Jan 2016 13:19:42 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://lovelock.github.io/symfony/symfony3-02-installation/</guid>
      <description>

&lt;h2 id=&#34;安装操作系统:8919fb557193e13074fdff43d63fcfdf&#34;&gt;安装操作系统&lt;/h2&gt;

&lt;p&gt;操作系统当然需要Linux，不过如果非要在Windows也不是不可以，只是麻烦一点，我没有尝试。至于发行版，我的观点是个人的开发或者测试环境Debian是最合适的，我的习惯是用Debian的Sid也就是unstable版，软件足够新也足够多，能够很方便的满足各种需求。不建议在实体机上安装，最好用VirtualBox等虚拟机软件安装，如果是用VirtualBox则需要选择桥接的网络模式，如果用VMware Workdstation的话就不必了，Nat就可以了。安装过程这里不再详述，最小化安装即可。本文基于Virtualbox + Vagrant + Debian Sid。如果对Vagrant不了解，可以移步&lt;a href=&#34;http://lovelock.github.io/2015/11/03/vagrant%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;安装php:8919fb557193e13074fdff43d63fcfdf&#34;&gt;安装PHP&lt;/h2&gt;

&lt;p&gt;我用的是最新的PHP7，相关的包如下图
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-10%20%E4%B8%8B%E5%8D%881.25.27.png&#34; alt=&#34;PHP7.0安装截图&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意，在我写这篇文章时还没有官方的phpredis和phpmemecached的包，需要自行编译安装。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;安装nginx:8919fb557193e13074fdff43d63fcfdf&#34;&gt;安装Nginx&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sudo apt-get install nginx&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装composer:8919fb557193e13074fdff43d63fcfdf&#34;&gt;安装composer&lt;/h2&gt;

&lt;p&gt;又到了问候GFW的时候了，不要考虑用官方的安装脚本了，最简单粗暴的方式就是直接&lt;a href=&#34;https://getcomposer.org/composer.phar&#34; target=&#34;_blank&#34;&gt;下载&lt;/a&gt;下来&lt;code&gt;composer.phar&lt;/code&gt;这个包。然后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/Downloads
sudo chmod +x composer.phar
sudo ln -s /home/frost/Downloads/composer.phar /usr/local/bin/composer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最关键的，要配置上&lt;a href=&#34;http://pkg.phpcomposer.com&#34; target=&#34;_blank&#34;&gt;Packagist/Composer中国全量镜像&lt;/a&gt;提供的镜像地址，建议直接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;composer config -g repositories.packagist composer http://packagist.phpcomposer.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可。&lt;/p&gt;

&lt;h2 id=&#34;安装symfnoy3:8919fb557193e13074fdff43d63fcfdf&#34;&gt;安装Symfnoy3&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo curl -LsS https://symfony.com/installer -o /usr/local/bin/symfony
$ sudo chmod a+x /usr/local/bin/symfony
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行一下&lt;code&gt;symfony&lt;/code&gt;，如果安装正常的话就能看到它的帮助信息了。&lt;/p&gt;

&lt;h2 id=&#34;新建symfony3应用:8919fb557193e13074fdff43d63fcfdf&#34;&gt;新建Symfony3应用&lt;/h2&gt;

&lt;p&gt;首先选定一个目录，我的做法是在Debian虚拟机的&lt;code&gt;/var/www/symfony.dev&lt;/code&gt;目录，然后回到宿主机，修改&lt;code&gt;Vagrantfile&lt;/code&gt;，添加一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.vm.synced_folder &amp;quot;./Symfony.dev&amp;quot;, &amp;quot;/var/www/symfony.dev&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，如果这样配置，一定要在&lt;code&gt;Vagrantfile&lt;/code&gt;同级目录下，新建一个Symfony.dev目录。在当前目录下执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vagrant halt
$ vagrant up
$ vagrant ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就又回到了虚拟机了。而且这时你可以在宿主机上用你喜欢的IDE或者边编辑器了。回到&lt;code&gt;/var/www/symfony.dev&lt;/code&gt;目录，执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ symfony new symfony.dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会在当前目录下新建一个名为symfony.dev的Symfony项目。&lt;/p&gt;

&lt;h2 id=&#34;配置php-fpm和nginx:8919fb557193e13074fdff43d63fcfdf&#34;&gt;配置PHP-FPM和Nginx&lt;/h2&gt;

&lt;p&gt;Symfony项目可能由于安全上的考虑，使用了依赖操作系统实现的ACL，我也不想关心这个ACL是什么，但如果想简单一点让你的程序马上可以运行，就需要避免这个陷阱。我的做法是修改&lt;code&gt;/etc/php/7.0/fpm/pool.d/www.conf&lt;/code&gt;中的下列字段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;user = frost
group = frost
listen = /run/php7.0-fpm.socket
listen.owner = frost
listen.group = frost
listen.mode = 0660
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时修改&lt;code&gt;/etc/nginx/nginx.conf&lt;/code&gt;中的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;user frost;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意其中的用户相关的地方我都改成了frost，也就是我在虚拟机中用的用户名。首先要明确，这两个地方的用户设置必须是一致的，通常来说，这样的配置加上相应的vhost设置，应该就可以让Web应用工作了，但对于Symfony这样还不行，或者说因为我用了Vagrant这样还不行。&lt;/p&gt;

&lt;p&gt;因为是一个共享目录，所以权限的设置上可能有一些限制，Symfony3要求&lt;code&gt;symfony.dev/var&lt;/code&gt;目录的权限是777，以便可以正常的写入日志和缓存等文件，但如果我要把它设置成777，宿主机就不乐意了。于是乎就只能让我的当前用户运行Nginx和FPM，这样他们自然对这个目录就有了写权限，变相的解决了这个问题。&lt;/p&gt;

&lt;p&gt;注意生产环境可不能这么乱来，千万不要用可以登录的用户名运行这种程序。一般用nobody或者www-data。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;server {
	listen 80;

	root /var/www/symfony.dev/symfony.dev/web;

	index index.php index.html;

	server_name symfony.dev www.symfony.dev;

	location / {
		try_files $uri /app.php$is_args$args;
	}

	location ~ ^/(app_dev|config)\.php(/|$) {
		fastcgi_pass unix:/run/php7.0-fpm.socket;
		fastcgi_split_path_info ^(.+\.php)(/.*)$;
		include fastcgi_params;
		fastcgi_param  SCRIPT_FILENAME  $realpath_root$fastcgi_script_name;
		fastcgi_param DOCUMENT_ROOT $realpath_root;
	}
    # PROD
	location ~ ^/app\.php(/|$) {
		fastcgi_pass unix:/run/php7.0-fpm.socket;
		fastcgi_split_path_info ^(.+\.php)(/.*)$;
		include fastcgi_params;
		fastcgi_param  SCRIPT_FILENAME  $realpath_root$fastcgi_script_name;
		fastcgi_param DOCUMENT_ROOT $realpath_root;
		internal;
        }

        error_log /var/log/nginx/symfony_error.log;
        access_log /var/log/nginx/symfony_access.log;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意其中的&lt;code&gt;fastcgi_pass&lt;/code&gt;一定要和你实际的设置一样。具体查看&lt;code&gt;/etc/php/7.0/fpm/pool.d/www.conf&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这时一切都已经准备就绪了，但最好还是再用&lt;code&gt;bin/symfony_requirements&lt;/code&gt;这个工具检查一下是否所有需求都已经满足了，不然后面可能还会遇到各种各样的问题。值得一提的是刚刚从2.8升级到3.0的时候就已经看到了一个小bug，在执行完这个命令之后，如果全部满足，会提示『满足了Symfony2的运行条件』，明显是忘了改，但现在已经3.0.1了，这个bug还没有修复。。。&lt;/p&gt;

&lt;p&gt;上面的配置中可以看到我用的是symfony.dev这个域名，在宿主机上配一下hosts，就以访问&lt;a href=&#34;http://symfony.dev&#34; target=&#34;_blank&#34;&gt;http://symfony.dev&lt;/a&gt;了。这时候你会发现是不能正常执行的，因为在&lt;code&gt;web/app_dev.php&lt;/code&gt;中制定了如果不是从&lt;code&gt;127.0.0.1&lt;/code&gt;来的请求就拒绝。所以直接把那段删了就行。&lt;/p&gt;

&lt;p&gt;好了可以进行下一步了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Symfony3学习第一章-简介</title>
      <link>http://lovelock.github.io/symfony/Symfony3-01-introduction/</link>
      <pubDate>Sun, 10 Jan 2016 13:07:27 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://lovelock.github.io/symfony/Symfony3-01-introduction/</guid>
      <description>&lt;p&gt;断断续续也看了好几次Symfony框架了，但总没有研究深入，即便如此，每次再看的时候都能比上一次理解的更深入一些。&lt;/p&gt;

&lt;p&gt;这次决定把其他的学习都先放一放，深入的研究一下Symfony的设计思想，还有相关的Bundles,Components等等，达到熟练掌握的程度。&lt;/p&gt;

&lt;p&gt;言归正传，Symfony是什么？&lt;/p&gt;

&lt;p&gt;Symfony是一个『大而全』的PHP框架，一个标准的Symfony安装就几乎可以满足你所有的需求了，包括一个高端的ORM框架doctrine、高效而安全的模板引擎Twig、简单但表达能力强的配置方案yaml、资源管理工具assets等等。如果你说这些东西单拎出来也很强大，我为什么要用它呢？因为Symfony把它们高度解耦，保证单个Bundle的独立性，但又用强大的Service Container把它们强力的结合在一起。如果你知道Laravel，可能也已经知道了Laravel的作者其实是Symfony的粉丝。Symfony的官网还有一篇最初的作者写的『如何写一个PHP框架』，我甚至在想Laravel是不是就是看了这篇教程才写出来的。&lt;/p&gt;

&lt;p&gt;不管怎样，Symfony为PHP开发者提供了一个完整的开发环境，让我们很快就能开发出需要的产品。有人会说这种重量级的框架会让程序运行变的缓慢，但在公司用了号称『性能最好的PHP框架Yaf』之后，我觉得我还是更喜欢PHP写的框架（我还没有接触过Phalcon，可能比Yaf好用一点）。为了获得更好的性能带来的是引入外部组件困难，不支持最新的编程范式（PSR），升级维护不容易。作为开发者，我更倾向于用『开发者友好』而不是『机器友好』的框架，这可能也是国外Ruby比较流行的原因吧。&lt;/p&gt;

&lt;p&gt;本系列文章一方面是自己学习的总结，也为后来人提供一些捷径，不用去读冗长的官方文档了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>