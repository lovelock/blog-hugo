<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Php on Me &amp; Web</title>
    <link>http://localhost:1313/tags/php/</link>
    <description>Recent content in Php on Me &amp; Web</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>frostwong@gmail.com (Frost Wong)</managingEditor>
    <webMaster>frostwong@gmail.com (Frost Wong)</webMaster>
    <copyright>(c) 2013-2016 Frost Wong. All rights reserved.</copyright>
    <lastBuildDate>Sat, 18 Jun 2016 07:04:22 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/php/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>理解PHP的Service Container</title>
      <link>http://localhost:1313/php/understanding-PHP-container/</link>
      <pubDate>Sat, 18 Jun 2016 07:04:22 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/understanding-PHP-container/</guid>
      <description>

&lt;p&gt;前段时间一直在花时间研究依赖注入的问题，现在虽然也没有研究的很透彻，但有了一些很模糊的概念，是时间把它总结一下了，既帮助自己理解，也能给现在还没有理解的同学们一点启发。&lt;/p&gt;

&lt;p&gt;本文将从以下几点展开。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;什么是依赖注入？为什么要有依赖注入？&lt;/li&gt;
&lt;li&gt;什么是Service Container(服务容器）？它和Docker的Container有关系吗？又有什么用？&lt;/li&gt;
&lt;li&gt;以Pimple为例，通过解读源代码来分析实现一个简单的Service Container。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;什么是依赖注入-为什么要有依赖注入&#34;&gt;什么是依赖注入？为什么要有依赖注入？&lt;/h2&gt;

&lt;p&gt;举个最常见到的例子来讲，比如我们的代码分层中有业务逻辑层(Logic层）和数据库操作层(Dao层），那在L层如何调用D层的代码呢？多数情况下可能会像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
&amp;lt;?php

class Sample
{
    private $daoSample;

    public function __construct()
    {
        $this-&amp;gt;daoSample = new DaoSample();
    }

    public function setDao(DaoInterface $dao)
    {
        $this-&amp;gt;daoSample = $dao;
    }
    
    public function newAccount($params)
    {
        $this-&amp;gt;daoSample-&amp;gt;addRecord($params);
    }
}

&amp;lt;?php

class Sample
{
    const TABLE_NAME = &#39;t_Sample&#39;;

    public function addRecord($params)
    {
        echo __METHOD__ . &amp;quot;\n&amp;quot;;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这样的依赖注入，我们在写业务层代码的时候就可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$logicSample = new Logic\Sample();
$logicSample-&amp;gt;newAccount($params);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完全不用考虑用的是什么类型的数据库操在类了，只需要保证它能够完成任务即可。&lt;/p&gt;

&lt;p&gt;这是个极端简化的例子，在实际的工作中，可能会遇到一个类依赖很多个类的情况，如果把每个依赖都写到构造函数里，也不是不可以，但维护起来也是挺麻烦的。&lt;br /&gt;
有一个“看起来”更简单一点的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

class Sample
{
    private $daoSample;

    public function __construct(DaoInterface $dao)
    {
        $this-&amp;gt;daoSample = $dao;
    }

    public function setDao(DaoInterface $dao)
    {
        $this-&amp;gt;daoSample = $dao;
    }
    
    public function newAccount($params)
    {
        $this-&amp;gt;daoSample-&amp;gt;addRecord($params);
    }
}

&amp;lt;?php

class Sample
{
    const TABLE_NAME = &#39;t_Sample&#39;;

    public function addRecord($params)
    {
        echo __METHOD__ . &amp;quot;\n&amp;quot;;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这样在调用的时候就需要这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$daoSample = new Dao\Sample();
$logicSample = new Logic\Sample($daoSample);
$logicSample-&amp;gt;newAccount($params);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要额外维护底层工具类的初始化。看起来更复杂了，但我觉得“依赖注入容器”的思想恰恰是从这样的用法中通过更深层次的思考得到的。&lt;/p&gt;

&lt;h2 id=&#34;什么是service-container-服务容器-它和docker的container有关系吗-又有什么用&#34;&gt;什么是Service Container(服务容器）？它和Docker的Container有关系吗？又有什么用？&lt;/h2&gt;

&lt;p&gt;我们把像&lt;code&gt;Dao\Sample&lt;/code&gt;这样的类叫做“服务”吧，现在在使用这些服务之前需要自己来管理&lt;strong&gt;服务的初始化&lt;/strong&gt;，那么有没有办法把这个工作托管出去呢？&lt;br /&gt;
最直观的想法可能就是把这些”服务“放在一个容器里，需要的时候直接拿来用就行。那么问题又来了，还是需要先给它初始化，然后才能放在容器里，再多想一步，能不能让容器自己来管理里它的初始化？&lt;/p&gt;

&lt;p&gt;当我需要一个服务时，就取容器里取，如果该服务在容器中定义了，但还没有初始化，那容器就给它初始化，并把这个实例保存下来，下次再有别的地方使用该服务时直接拿来用即可。&lt;/p&gt;

&lt;p&gt;这就是依赖注入容器的理想状态了吧。&lt;/p&gt;

&lt;p&gt;它和Docker的容器当然没有任何关系。&lt;/p&gt;

&lt;p&gt;虽然都叫容器，但它们解决的问题或者说痛点其实是不同的。依赖注入容器解决的是服务随取随用，Docker的容器本质上把一个服务相关的所有东西打包在一起，找到一个宿主机它就能在自己的空间内跑起来，它解决的问题是一次生成，到处运行的问题，从这点上看有点像Java的口号。&lt;/p&gt;

&lt;h2 id=&#34;实现一个简单的service-container&#34;&gt;实现一个简单的Service Container&lt;/h2&gt;

&lt;p&gt;没错，我们是PHP开发者，那我们一定很喜欢数组，对不对？&lt;/p&gt;

&lt;p&gt;好，那我们就来实现一个和数组用起来差不多的依赖注入容器。（主要参考了Pimple的实现）&lt;/p&gt;

&lt;h3 id=&#34;功能设计&#34;&gt;功能设计&lt;/h3&gt;

&lt;h3 id=&#34;api设计&#34;&gt;API设计&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>为PHP添加全局函数</title>
      <link>http://localhost:1313/php/internals/create-functions/</link>
      <pubDate>Thu, 14 Apr 2016 22:12:56 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/internals/create-functions/</guid>
      <description>

&lt;p&gt;这几天一直没有抽出空来写，都快忘了。&lt;/p&gt;

&lt;p&gt;下面开始写第一个函数。注意这里我说&lt;strong&gt;函数&lt;/strong&gt;而不是&lt;strong&gt;方法&lt;/strong&gt;，是有意要和&lt;strong&gt;类的方法&lt;/strong&gt;做区分。因为这里的&lt;strong&gt;函数&lt;/strong&gt;是全局的。&lt;/p&gt;

&lt;p&gt;不能忘了咱们的功能设计，这里我需要一个这样的名叫&lt;code&gt;format_log&lt;/code&gt;函数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;接收一个字符串，用&lt;code&gt;sprintf&lt;/code&gt;格式化以后传递给&lt;code&gt;str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接收若干个字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先要思考几个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;怎么在PHP的命名空间中注册这个函数？&lt;/li&gt;
&lt;li&gt;怎么接收参数？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;在php命名空间中注册一个函数&#34;&gt;在PHP命名空间中注册一个函数&lt;/h2&gt;

&lt;p&gt;找到这里&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* {{{ hylog_functions[]
 *
 * Every user visible function must have an entry in hylog_functions[].
 */
const zend_function_entry hylog_functions[] = {
    PHP_FE(confirm_hylog_compiled,  NULL)       /* For testing, remove later. */
    PHP_FE_END  /* Must be the last line in hylog_functions[] */
};
/* }}} */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意注释，“所有用户可见的函数都需要在&lt;code&gt;hylog_functions[]&lt;/code&gt;中有一个入口”。所以，我在里面添加一行，变成这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* {{{ hylog_functions[]
 *
 * Every user visible function must have an entry in hylog_functions[].
 */
const zend_function_entry hylog_functions[] = {
    PHP_FE(confirm_hylog_compiled,  NULL)       /* For testing, remove later. */
    PHP_FE(format_log, NULL)
    PHP_FE_END  /* Must be the last line in hylog_functions[] */
};
/* }}} */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先不用管第二个参数&lt;code&gt;NULL&lt;/code&gt;，现在只需要知道它和目标函数要接收的参数有关即可，后面会详细讲述。现在函数&lt;code&gt;format_log&lt;/code&gt;已经注册进了PHP了，但入口又在哪里呢？顺着&lt;code&gt;hylog_functions&lt;/code&gt;找，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* {{{ hylog_module_entry
 */
zend_module_entry hylog_module_entry = {
	STANDARD_MODULE_HEADER,
	&amp;quot;hylog&amp;quot;,
	hylog_functions,
	PHP_MINIT(hylog),
	PHP_MSHUTDOWN(hylog),
	PHP_RINIT(hylog),		/* Replace with NULL if there&#39;s nothing to do at request start */
	PHP_RSHUTDOWN(hylog),	/* Replace with NULL if there&#39;s nothing to do at request end */
	PHP_MINFO(hylog),
	PHP_HYLOG_VERSION,
	STANDARD_MODULE_PROPERTIES
};
/* }}} */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到花括号中的第三个变量。刚才我们说了，所有用户可见的函数需要写在&lt;code&gt;hylog_functions&lt;/code&gt;里，现在又把它打包传给&lt;code&gt;zend_module_entry&lt;/code&gt;类型的变量了。至于后面的几个宏，其中&lt;code&gt;PHP_MINIT&lt;/code&gt;和&lt;code&gt;PHP_MSHUTDOWN&lt;/code&gt;是一对，表示&lt;strong&gt;模块&lt;/strong&gt;的启动和关闭，所谓模块，其实就是扩展了；&lt;code&gt;PHP_RINIT&lt;/code&gt;和&lt;code&gt;PHP_RSHUTDOWN&lt;/code&gt;是一对，表示&lt;strong&gt;请求&lt;/strong&gt;的开始和关闭；&lt;code&gt;PHP_MINFO&lt;/code&gt;用来控制&lt;code&gt;phpinfo()&lt;/code&gt;或&lt;code&gt;php -i&lt;/code&gt;的输出中关于本扩展的信息；&lt;code&gt;PHP_HYLOG_VERSION&lt;/code&gt;就是本扩展的版本号了。这些后面会详述(TODO)。至于&lt;code&gt;STANDARD_MODULE_PROPERTIES&lt;/code&gt;，就是一个内置了宏了，暂时也不用管它。(TODO问问鸟哥）&lt;/p&gt;

&lt;p&gt;那最关键的一步还没做呢，实现该方法。&lt;/p&gt;

&lt;p&gt;PHP为我们提供了一个宏来定义函数，&lt;code&gt;ZEND_FUNCTION&lt;/code&gt;或&lt;code&gt;PHP_FUNCTION&lt;/code&gt;，它两个本质上是一样的，不过既然到现在生成的骨架里面还在用&lt;code&gt;PHP_FUNCTION&lt;/code&gt;，那我们姑且就保持一致吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;PHP_FUNCTION(format_log)
{
	char str[] = &amp;quot;hylog&amp;quot;;
	
	php_printf(&amp;quot;Hello, %s\n&amp;quot;, str);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把它写在和&lt;code&gt;confirm_hylog_compiled&lt;/code&gt;相同的那块区域。现在执行&lt;code&gt;rebuild.sh&lt;/code&gt;，然后&lt;code&gt;php -r &#39;format_log();&lt;/code&gt;应该就能看到&lt;code&gt;Hello, extenstion&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;等等，我们说好的是要接收输入参数的，怎么现在又是一个没有参数的函数？没关系，刚才只是为了验证一下方法是否走的通，现在我们来考虑接收参数。&lt;/p&gt;

&lt;h2 id=&#34;接收参数的函数&#34;&gt;接收参数的函数&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——扩展的骨架</title>
      <link>http://localhost:1313/php/internals/create-skeleton-of-extension/</link>
      <pubDate>Sat, 09 Apr 2016 22:04:18 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/internals/create-skeleton-of-extension/</guid>
      <description>

&lt;p&gt;前面啰嗦了这么多读者都要没有兴趣了。从现在起要真正开始PHP扩展开发阶段了。&lt;/p&gt;

&lt;p&gt;首先来生成扩展的骨架。所谓骨架就是一个扩展需要的基本文件了。&lt;/p&gt;

&lt;h2 id=&#34;获取php源码&#34;&gt;获取PHP源码&lt;/h2&gt;

&lt;p&gt;截至目前，PHP最新源码是7.0.5。&lt;a href=&#34;http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror&#34;&gt;下载链接&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  projects wget http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror -O php705.tar.bz2
--2016-04-09 10:18:39--  http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror
Resolving cn2.php.net (cn2.php.net)... 202.108.35.194, 202.108.35.235, 202.108.35.237, ...
Connecting to cn2.php.net (cn2.php.net)|202.108.35.194|:80... connected.
HTTP request sent, awaiting response... 302 Found
Location: http://cn2.php.net/distributions/php-7.0.5.tar.bz2 [following]
--2016-04-09 10:18:39--  http://cn2.php.net/distributions/php-7.0.5.tar.bz2
Reusing existing connection to cn2.php.net:80.
HTTP request sent, awaiting response... 200 OK
Length: 14086522 (13M) [application/octet-stream]
Saving to: ‘php705.tar.bz2’

php705.tar.bz2                             100%[=======================================================================================&amp;gt;]  13.43M  4.49MB/s    in 3.0s

2016-04-09 10:18:42 (4.49 MB/s) - ‘php705.tar.bz2’ saved [14086522/14086522]

➜  projects md5sum php705.tar.bz2
b15e6836babcbf0aa446678ee38f896b  php705.tar.bz2
➜  projects echo b15e6836babcbf0aa446678ee38f896b
b15e6836babcbf0aa446678ee38f896b
➜  projects tar xjf php705.tar.bz2
➜  projects cd php-7.0.5/ext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于来到了正题了。我现在也终于明白鸟哥为啥费劲写个生成Yaf最小化应用的脚本了，就是从写扩展的经历中得来的，既然可以帮用户做的更多，那就帮一下好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  ext ./ext_skel --extname=hylog
Creating directory hylog
Creating basic files: config.m4 config.w32 .gitignore hylog.c php_hylog.h CREDITS EXPERIMENTAL tests/001.phpt hylog.php [done].

To use your new extension, you will have to execute the following steps:

1.  $ cd ..
2.  $ vi ext/hylog/config.m4
3.  $ ./buildconf
4.  $ ./configure --[with|enable]-hylog
5.  $ make
6.  $ ./sapi/cli/php -f ext/hylog/hylog.php
7.  $ vi ext/hylog/hylog.c
8.  $ make

Repeat steps 3-6 until you are satisfied with ext/hylog/config.m4 and
step 6 confirms that your module is compiled into PHP. Then, start writing
code and repeat the last two steps as often as necessary.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，&lt;code&gt;ext_skel&lt;/code&gt;就帮我们生成了一个名为&lt;code&gt;hylog&lt;/code&gt;的扩展框架。&lt;/p&gt;

&lt;p&gt;下面要介绍一下安装扩展的两种方式了，一种是直接编译进PHP，一种是接下来我们要讨论的这种，即动态加载的扩展。&lt;/p&gt;

&lt;p&gt;什么是直接编译进PHP呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  ext cd hylog
➜  hylog ls
config.m4  config.w32  CREDITS  EXPERIMENTAL  hylog.c  hylog.php  php_hylog.h  tests
➜  hylog vim config.m4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会看到这样的几行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;dnl If your extension references something external, use with:

dnl PHP_ARG_WITH(hylog, for hylog support,
dnl Make sure that the comment is aligned:
dnl [  --with-hylog             Include hylog support])

dnl Otherwise use enable:

dnl PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
dnl [  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的&lt;code&gt;dnl&lt;/code&gt;是注释，主要看&lt;code&gt;--with-hylog&lt;/code&gt;和&lt;code&gt;--enable-hylog&lt;/code&gt;。假定你来看本文，你一定自己编译过PHP了，如果没有，那先去整一遍再回来看吧：）
是这样的，我们在编译PHP的时候经常会碰到类似这种&lt;code&gt;--with[out]-blah=/path/to/foo&lt;/code&gt;或者&lt;code&gt;--enable-blah&lt;/code&gt;或者&lt;code&gt;--disable-blah&lt;/code&gt;的选项吧。其实对编写扩展的我们来说，这两种都是可行的，并没有本质上的区别，只是一般用&lt;code&gt;--with&lt;/code&gt;会带个路径，告诉PHP这个扩展依赖的外部库的路径，而&lt;code&gt;--enable&lt;/code&gt;则表示该扩展是独立的，或者依赖的库在默认的搜索路径内。&lt;/p&gt;

&lt;p&gt;那和我们说的两种安装方式有什么关系呢？不如我们就来真的安装一下看看效果吧。&lt;/p&gt;

&lt;p&gt;看上面的注释，我们知道了需要把&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;dnl PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
dnl [  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段改成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
[  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于是喜欢用&lt;code&gt;--enable&lt;/code&gt;还是喜欢用&lt;code&gt;--with&lt;/code&gt;看个人喜好了，因为本例中并没有用到外部依赖，所以用&lt;code&gt;--enable&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;提醒一下，改完之后最好把当前的这个状态保存下来——创建一个git工作目录就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git init
Initialized empty Git repository in /home/frost/projects/php-7.0.5/ext/hylog/.git/
➜  hylog git:(master) ✗ gst
On branch master

Initial commit

Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

	.gitignore
	CREDITS
	EXPERIMENTAL
	config.m4
	config.w32
	hylog.c
	hylog.php
	php_hylog.h
	tests/

nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
➜  hylog git:(master) ✗ ga .
➜  hylog git:(master) ✗ gc -m &#39;init hylog&#39;
[master (root-commit) 58e5e4a] init hylog
 Committer: frost &amp;lt;frost@debian.unixera.com&amp;gt;
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly. Run the
following command and follow the instructions in your editor to edit
your configuration file:

    git config --global --edit

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author

 9 files changed, 409 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 CREDITS
 create mode 100644 EXPERIMENTAL
 create mode 100644 config.m4
 create mode 100644 config.w32
 create mode 100644 hylog.c
 create mode 100644 hylog.php
 create mode 100644 php_hylog.h
 create mode 100644 tests/001.phpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么要这么做呢？其实主要是想让这个目录干净，因为待会儿执行了一些命令之后会生成很多文件，如果你想清除这些文件就变得很麻烦。但现在我只把这些文件&lt;code&gt;commit&lt;/code&gt;了，待会儿生成文件后，如果我想删除，就可以用&lt;code&gt;git clean -df&lt;/code&gt;，立即回到现在的状态。但关于&lt;code&gt;git&lt;/code&gt;的操作，那就是另外一回事了（强烈推荐&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#34;&gt;廖雪峰的git教程&lt;/a&gt;)。&lt;/p&gt;

&lt;h3 id=&#34;编译进php&#34;&gt;编译进PHP&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;重新生成配置文件&lt;/p&gt;

&lt;p&gt;注意其中的&lt;code&gt;./buildconf --force&lt;/code&gt;，之所以带&lt;code&gt;--force&lt;/code&gt;是因为我们是在正式版的PHP源码中进行操作的，正常情况下使用这种方式编译的都是内建扩展，例如&lt;code&gt;PDO&lt;/code&gt;这种，是PHP官方团队开发的，所以你非要用这种方式编译的话，就强制一下好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git:(master) cd ..
➜  ext cd ..
➜  php-7.0.5 ./buildconf --force
Forcing buildconf
Removing configure caches
buildconf: checking installation...
buildconf: autoconf version 2.69 (ok)
rebuilding aclocal.m4
rebuilding configure
rebuilding main/php_config.h.in
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找变化&lt;/p&gt;

&lt;p&gt;刚刚的操作背后发生了什么呢？注意&lt;code&gt;rebuilding&lt;/code&gt;的三行，那我们就挨个看看。分别在三个文件中搜索&lt;code&gt;hylog&lt;/code&gt;关键字吧。
在&lt;code&gt;aclocal.m4&lt;/code&gt;中未找到变化。
在&lt;code&gt;configure&lt;/code&gt;中有大量变化，稍后介绍能看到的变化。
在&lt;code&gt;main/php_config.h.in&lt;/code&gt;中，增加了两行，用来取消&lt;code&gt;COMPILE_DL_HYLOG&lt;/code&gt;的定义，表示该扩展不是动态加载。&lt;/p&gt;

&lt;p&gt;这时检查一下&lt;code&gt;configure --help&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --help | grep hylog
  --enable-hylog           Enable hylog support
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;诶，有点眼熟对不对？就是刚才在&lt;code&gt;ext/hylog/config.m4&lt;/code&gt;中取消注释的内容。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编译PHP&lt;/p&gt;

&lt;p&gt;既然要把它编译进来，那就加上&lt;code&gt;--enable-hylog&lt;/code&gt;吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --enable-hylog
➜  php-7.0.5 make
➜  php-7.0.5 sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看已安装的扩展&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 php -v
PHP 7.0.5 (cli) (built: Apr  9 2016 11:08:08) ( NTS )
Copyright (c) 1997-2016 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies
➜  php-7.0.5 php -m
[PHP Modules]
Core
ctype
date
dom
fileinfo
filter
hash
hylog
iconv
json
libxml
pcre
PDO
pdo_sqlite
Phar
posix
Reflection
session
SimpleXML
SPL
sqlite3
standard
tokenizer
xml
xmlreader
xmlwriter
    
[Zend Modules]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以看到我们新创建的扩展已经编译进PHP了——虽然它没有任何功能。可以再到&lt;code&gt;/usr/local/lib/php/extensions/no-debug-non-zts-20151012&lt;/code&gt;中验证一下是不是真的没有&lt;code&gt;hylog.so&lt;/code&gt;存在。&lt;/p&gt;

&lt;p&gt;所以如果不想用它了怎么办呢？你当然可以选择无视它，但最好还是卸载了吧，卸载的方法也很简单，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --disable-hylog
➜  php-7.0.5 make
➜  php-7.0.5 sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来就是三行，其实要用很长时间，所以，像我们这样的第三方扩展开发者还是不要用这种方式比较好。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;动态加载&#34;&gt;动态加载&lt;/h3&gt;

&lt;p&gt;动态加载方式是把每个扩展编译成一个单独的&lt;code&gt;.so&lt;/code&gt;文件，然后在&lt;code&gt;php.ini&lt;/code&gt;中加上&lt;code&gt;extension=hylog.so&lt;/code&gt;，如果有配置就再加上一些配置。CLI的话就直接生效了，FPM环境下就要重启一下FPM了。我们这里只讨论CLI模式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第三方扩展安装的一般流程&lt;/p&gt;

&lt;p&gt;还记得我刚刚提到的执行某些命令后会生成很多文件吗？就是这里了。如果你还没有用&lt;code&gt;git&lt;/code&gt;，我劝你现在用了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git:(master) phpize
Configuring for:
PHP Api Version:         20151012
Zend Module Api No:      20151012
Zend Extension Api No:   320151012
➜  hylog git:(master) ✗ ./configure
➜  hylog git:(master) ✗ make
➜  hylog git:(master) ✗ sudo make install
Installing shared extensions:     /usr/local/lib/php/extensions/no-debug-non-zts-20151012/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好，到这里已经看到在独立编译动态扩展时，生成的&lt;code&gt;.so&lt;/code&gt;文件是放在了这个目录下的。这时动态的好处就体现出来了。文件有了，至于你想不想用，只需要修改&lt;code&gt;php.ini&lt;/code&gt;即可，不用任何重新编译。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装和卸载扩展&lt;/p&gt;

&lt;p&gt;前面说了，如果需要该扩展，编辑&lt;code&gt;/usr/local/lib/php.ini&lt;/code&gt;，在最下面添加（安装）或删除（卸载）一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;extension=hylog.so
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调试&lt;/p&gt;

&lt;p&gt;我可不敢保证代码一次就能成功，调试的时候要多次执行以上三个命令，所以可以创建一个&lt;code&gt;rebuild.sh&lt;/code&gt;脚本，运行脚本重新编译并安装最新的版本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最好把它加入到&lt;code&gt;git&lt;/code&gt;工作目录中。&lt;/p&gt;

&lt;p&gt;扩展的安装就这些，下一节介绍PHP变量的基本类型。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——用PHP实现类的原型</title>
      <link>http://localhost:1313/php/internals/class-prototype-in-php/</link>
      <pubDate>Sat, 09 Apr 2016 21:55:00 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/internals/class-prototype-in-php/</guid>
      <description>&lt;p&gt;在编写之前先用PHP实现这个类的原型吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

namespace Hylog;

use \DateTime;

class Hylog
{
    const HYLOG_VERSION = &amp;quot;0.1.0&amp;quot;;

    const EMERGENCY = &#39;EMERGENCY&#39;;
    const ALERT     = &#39;ALERT&#39;;
    const CRITICAL  = &#39;CRITICAL&#39;;
    const ERROR     = &#39;ERROR&#39;;
    const WARNING   = &#39;WARNING&#39;;
    const NOTICE    = &#39;NOTICE&#39;;
    const INFO      = &#39;INFO&#39;;
    const DEBUG     = &#39;DEBUG&#39;;

    private static $_instance;

    private $_basePath;
    private $_sliceLogByHour;

    public function log($level, $message, $context = array())
    {
        $line = $this-&amp;gt;interpolate($message, $context);

        $datetime         = new DateTime();
        $timestamp        = $datetime-&amp;gt;getTimestamp();
        $formatedDatetime = $datetime-&amp;gt;format(DateTime::ATOM);

        $line = $timestamp . &amp;quot;\t|\t&amp;quot; . $formatedDatetime . &amp;quot;\t|\t&amp;quot; . $line;

        $this-&amp;gt;output($level, $line);
    }

    public function emergency($message, $context = array())
    {
        $this-&amp;gt;log(self::EMERGENCY, $message, $context);
    }

    public function alert($message, $context = array())
    {
        $this-&amp;gt;log(self::ALERT, $message, $context);
    }

    public function critical($message, $context = array())
    {
        $this-&amp;gt;log(self::CRITICAL, $message, $context);
    }

    public function error($message, $context = array())
    {
        $this-&amp;gt;log(self::ERROR, $message, $context);
    }

    public function warning($message, $context = array())
    {
        $this-&amp;gt;log(self::WARING, $message, $context);
    }

    public function notice($message, $context = array())
    {
        $this-&amp;gt;log(self::NOTICE, $message, $context);
    }

    public function info($message, $context = array())
    {
        $this-&amp;gt;log(self::INFO, $message, $context);
    }

    public function debug($message, $context = array())
    {
        $this-&amp;gt;log(self::DEBUG, $message, $context);
    }

    public static function getInstance() : object
    {
        if (!isset(self::$_instance)) {
            self::$_instance = new static();
        }

        return self::$_instance;
    }

    public function getVersion()
    {
        return self::HYLOG_VERSION;
    }

    public function setBasePath($path)
    {
        $this-&amp;gt;_basePath = $path;
    }

    public function getBasePath() : string
    {
        return $this-&amp;gt;_basePath;
    }

    public function setSliceByHour($bool)
    {
        $this-&amp;gt;_sliceLogByHour = $bool;
    }

    public function getSliceByHour() : bool
    {
        return $this-&amp;gt;_sliceLogByHour;
    }

    private function output($level, $message)
    {
        $logFile = $this-&amp;gt;getLogFile($level);

        error_log($message . PHP_EOL, 3, $logFile);
    }

    private function getLogFile($level) : string
    {
        $cHour = date(&#39;ymdH&#39;);
        $cDay  = date(&#39;ymd&#39;);

        if ($this-&amp;gt;_sliceLogByHour) {
            return $this-&amp;gt;_basePath . &#39;/&#39; . $level . &#39;.&#39; . $cHour . &#39;.log&#39;;
        } else {
            return $this-&amp;gt;_basePath . &#39;/&#39; . $level . &#39;.&#39; . $cDay . &#39;.log&#39;;
        }
    }

    private function interpolate($message, $context = array())
    {
        foreach ($context as $key =&amp;gt; $val) {
            $replace[&#39;{&#39; . $key . &#39;}&#39;] = $val;
        }

        return strtr($message, $replace);
    }

    private function __construct()
    {
        $this-&amp;gt;_basePath = &#39;/tmp/log&#39;;

        if (!is_dir($this-&amp;gt;_basePath)) {
            mkdir($this-&amp;gt;_basePath, 0700, true);
        } else {
            chmod($this-&amp;gt;_basePath, 0700);
        }

        $this-&amp;gt;_sliceLogByHour = true;
    }

    private function __clone()
    {
    }

    private function __wakeup()
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——目标和计划</title>
      <link>http://localhost:1313/php/internals/schedules/</link>
      <pubDate>Sat, 09 Apr 2016 21:13:28 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/internals/schedules/</guid>
      <description>

&lt;p&gt;好了，现在来整理一下我们要做的工作。&lt;/p&gt;

&lt;h2 id=&#34;功能目标&#34;&gt;功能目标&lt;/h2&gt;

&lt;p&gt;既然是要做一个记日志的扩展，那当然就避免不了两个功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;格式化日志流&lt;/li&gt;
&lt;li&gt;将日志流推送到特定目标（通常是写入文件）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个是最核心的功能，其他的都是辅助。但辅助也可以很贴心，所以我设计了以下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;尽可能多的从扩展层面获取共用的信息，比如时间、客户端IP、当前机器的IP等（这里涉及&lt;strong&gt;超全局变量&lt;/strong&gt;的获取）&lt;/li&gt;
&lt;li&gt;设计尽量简单的默认规则，既可以开箱即用，又可以随心配置&lt;/li&gt;
&lt;li&gt;遵守&lt;a href=&#34;http://www.php-fig.org/psr/psr-3/&#34;&gt;PSR-3&lt;/a&gt;规范&lt;/li&gt;
&lt;li&gt;命名空间和传统写法的兼容(鸟哥的Yaf是教科书）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一个需要考虑的问题是高并发场景下的文件写入丢失问题，我觉得以我目前的水平是无法解决这个问题的，那没关系，PHP内置的已经有强大的&lt;code&gt;error_log&lt;/code&gt;方法了，它可以保证这点，用它就可以。喂等等，那既然已经有了&lt;code&gt;error_log&lt;/code&gt;，我干嘛还要做这个呢？&lt;/p&gt;

&lt;p&gt;因为它不够灵活。&lt;/p&gt;

&lt;p&gt;我们通常的做法是封装&lt;code&gt;error_log&lt;/code&gt;方法，填充默认参数、格式化、写入文件等，&lt;code&gt;error_log&lt;/code&gt;方法本身是很快的，但挡不住我们添加的这些代码的消耗也很大，因为写日志是个非常频繁的操作，所以一个极小的性能损失积累下来都可能影响很大。&lt;/p&gt;

&lt;h2 id=&#34;取名&#34;&gt;取名&lt;/h2&gt;

&lt;p&gt;既然用C写，那就是奔着高性能去的，High Performance PHP Log，叫Hilog貌似就可以，但为了致敬鸟哥，把i换成y好了：）所以叫Hylog。&lt;/p&gt;

&lt;h2 id=&#34;类的设计&#34;&gt;类的设计&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;拥有PRS-3规定的8个level作为常量&lt;/li&gt;
&lt;li&gt;对应8个方法，分别写到不同的文件&lt;/li&gt;
&lt;li&gt;一个log方法比上述8个方法多个level参数，上述8个函数实际是调用这个方法记日志的&lt;/li&gt;
&lt;li&gt;格式化日志的方法&lt;/li&gt;
&lt;li&gt;数组插值的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;依赖关系&#34;&gt;依赖关系&lt;/h2&gt;

&lt;p&gt;依赖PHP内置函数&lt;code&gt;error_log&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——背景介绍</title>
      <link>http://localhost:1313/php/internals/introduction/</link>
      <pubDate>Mon, 04 Apr 2016 22:37:18 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/internals/introduction/</guid>
      <description>

&lt;p&gt;这段时间其实在看C语言，但看来看去也不知道学了这些知识用在哪里。作为一名PHP程序员，想要进阶，当然得懂PHP的运行原理。那么，编写扩展就成了认识PHP的必经之路。而PHP的扩展当然是用C写的，这样，也给自己刚刚学的C语言找到了练手的项目。&lt;/p&gt;

&lt;p&gt;那么写个什么项目好呢？最好简单一些，但也要能涵盖编写一个完整功能的扩展的方方面面。忘了在哪里看到了&lt;a href=&#34;https://github.com/Neeke/SeasLog&#34;&gt;SeasLog&lt;/a&gt;，感觉这个项目很符合我的期望，于是上它的issue列表里面找到了一个功能请求，作者还没有着手做，那我就顺手帮忙做了吧，前几天已经被作者合并了，让我的信心也倍增。所以，我决定自己也再写一个类似的东西，主要目的是通过做一个完整的项目，各个击破PHP扩展编写过程中的所有问题。&lt;/p&gt;

&lt;p&gt;言归正传，先列上参考文献列表好了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.phpinternalsbook.com/&#34;&gt;PHP internals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/walu/phpbook&#34;&gt;PHP扩展开发及内核应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://php.net/manual/en/internals2.php&#34;&gt;PHP at the core: A Hacker&amp;rsquo;s Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/laruence/yaf&#34;&gt;Yaf源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.php.net/downloads.php&#34;&gt;PHP源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/laruence/php7-internal&#34;&gt;Understanding PHP7 Internal articles&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;声明&#34;&gt;声明：&lt;/h2&gt;

&lt;p&gt;本系列所描述的PHP扩展相关知识大部分基于PHP 7.0.x，与PHP 5.x不完全兼容，因为列表里的前三个文献都是讲PHP5的，所以我在编写本文时也碰到了不少兼容性问题，都是通过看Yaf源码和PHP源码搞定兼容性的，我没有提到的地方还请在留言中指出。我当然也希望我的这份绵薄之力能帮助弥补目前PHP7相关文档严重不足的情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>seaslog 和 error_log性能大比拼</title>
      <link>http://localhost:1313/php/log-bench/</link>
      <pubDate>Fri, 01 Apr 2016 16:33:19 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/log-bench/</guid>
      <description>

&lt;p&gt;今天花了点时间测试了开源项目&lt;a href=&#34;http://neeke.github.io/SeasLog/&#34;&gt;seaslog&lt;/a&gt;和PHP内置的error_log的性能。本文不涉及该扩展的安装和使用，如果对其不了解，可移步&lt;a href=&#34;http://neeke.github.io/SeasLog/&#34;&gt;官网&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;项目的描述有语法问题&amp;rdquo;A effective &amp;hellip;&amp;ldquo;，我提醒了原作者，然而并没有被理会。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;测试环境&#34;&gt;测试环境&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;Intel&amp;reg; Xeon&amp;reg; CPU  E5520  @ 2.27GHz 8核&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;48G&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;td&gt;7.0.1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Nginx&lt;/td&gt;
&lt;td&gt;1.2.7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;测试代码&#34;&gt;测试代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

error_log(&amp;quot;I am testing performance of error_log&amp;quot; . PHP_EOL, 3, __DIR__ . &#39;/error_log.log&#39;);
SeasLog::debug(&amp;quot;I am testing performance of seaslog&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果数据&#34;&gt;结果数据&lt;/h2&gt;

&lt;p&gt;每种方式测试5次，请求次数1000次，并发量分别是1, 10, 100, 1000。分别记录每次测试的QPS。&lt;/p&gt;

&lt;p&gt;1. error_log&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;并发量&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2430&lt;/td&gt;
&lt;td&gt;2579&lt;/td&gt;
&lt;td&gt;2685&lt;/td&gt;
&lt;td&gt;2484&lt;/td&gt;
&lt;td&gt;2622&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;7303&lt;/td&gt;
&lt;td&gt;7844&lt;/td&gt;
&lt;td&gt;5892&lt;/td&gt;
&lt;td&gt;11739&lt;/td&gt;
&lt;td&gt;9002&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;11763&lt;/td&gt;
&lt;td&gt;6107&lt;/td&gt;
&lt;td&gt;6921&lt;/td&gt;
&lt;td&gt;9258&lt;/td&gt;
&lt;td&gt;11999&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;891&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;889&lt;/td&gt;
&lt;td&gt;883&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2. seaslog&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;并发量&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2147&lt;/td&gt;
&lt;td&gt;2071&lt;/td&gt;
&lt;td&gt;2130&lt;/td&gt;
&lt;td&gt;2123&lt;/td&gt;
&lt;td&gt;2039&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;7415&lt;/td&gt;
&lt;td&gt;9438&lt;/td&gt;
&lt;td&gt;6901&lt;/td&gt;
&lt;td&gt;6445&lt;/td&gt;
&lt;td&gt;6047&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;7770&lt;/td&gt;
&lt;td&gt;9389&lt;/td&gt;
&lt;td&gt;6852&lt;/td&gt;
&lt;td&gt;5806&lt;/td&gt;
&lt;td&gt;6483&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;890&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;891&lt;/td&gt;
&lt;td&gt;760&lt;/td&gt;
&lt;td&gt;322&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;测试结果图&#34;&gt;测试结果图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/errorlog.png&#34; alt=&#34;error_log性能测试结果&#34; /&gt;
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/seaslog.png&#34; alt=&#34;seaslog性能测试结果&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;error_log的性能总体优于seaslog，但并没有压倒性优势&lt;/li&gt;
&lt;li&gt;在并发较高时二者都出现急剧性能下降，程度相当。怀疑瓶颈已经不在写日志，而在Nginx的处理能力了（待验证）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;seaslog使用起来更简单，不需要多层封装&lt;/li&gt;
&lt;li&gt;error_log输出的格式比较单一，如果要加上日期、IP等信息，一定会引入很多PHP函数调用，导致性能损失。但seaslog在这方面就有很大的想象空间，在扩展中计算时间、获取IP、详细的debug信息都是可能的。不过现在并没有加入这些功能。&lt;/li&gt;
&lt;li&gt;seaslog提供了类似PDO的插值方式，使用起来更方便&lt;/li&gt;
&lt;li&gt;seaslog可以自定义配置多&lt;/li&gt;
&lt;li&gt;一个细节，error_log在type=3时并没有在message后面加上换行符，需要自行添加，也就是说每次都要有一个字符串拼接，这在seaslog中得到了改进&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我之前看到有人说seaslog的日期格式太固定，因此我fork了一份代码加上了配置日期格式的功能，作者到现在都没有合并进主干呢。而且我觉得现在这个功能有些简陋，比如我前面说的第2点，请求的一些基本信息如果从扩展层面直接取到，就不需要再在外层调用PHP函数或通过超全局变量获取了，既简化了外层使用的方式，又提高性能。但作者貌似也没有继续增加功能的意思，可能作者并不想在扩展层面做太复杂的事情，要保持这个项目的简单、纯粹。&lt;/p&gt;

&lt;p&gt;我还是自己再维护一份好了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Symfony项目设计</title>
      <link>http://localhost:1313/symfony/symfony-project-design/</link>
      <pubDate>Thu, 14 Jan 2016 23:17:18 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/symfony/symfony-project-design/</guid>
      <description>

&lt;p&gt;终于收拾完家务可以坐下来写点东西了。&lt;/p&gt;

&lt;p&gt;今天忘了写周报，感到很不安。&lt;/p&gt;

&lt;p&gt;刚刚在知乎上看到，当你做的都是枯燥、重复的工作时，聪明人看到机遇，其余的人，只会抱怨。&lt;/p&gt;

&lt;p&gt;我恍然大悟，虽然也谈不上抱怨，但最近一段时间总是被运营页的需求搞到焦头烂额，虽然功能不难，只是时间问题，但时间成本才是最宝贵的啊。&lt;/p&gt;

&lt;p&gt;还有就是周报，每次周四都忘，都要领导提醒。这不是个好习惯，虽然刚入职的时候就有同事配了个邮件服务，每周四发邮件提醒发周报，然而毕竟不是一两句话能写清楚的，所以并没有什么卵用。然后我就想写一个工具可以实现这样的功能需求：&lt;/p&gt;

&lt;h2 id=&#34;需求&#34;&gt;需求&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;简易GTD&lt;/p&gt;

&lt;p&gt;以项目为单位的GTD，项目最好不要太大，因为我计划用项目的title作为周报的item，所以尽量把一个功能模块就作为一个项目。这样说起来，其实项目(project)这个词在这里用的并不好，应该用module。&lt;/p&gt;

&lt;p&gt;在这个title下可以有子module，不准备做无限分级，没有意义。只需要子module加上Notes功能。&lt;/p&gt;

&lt;p&gt;子module其实就是写你是怎样实现这个项目的，其中包括设计、实现、总结等等，子module可以带标签，设计几个常用的标签，支持自定义标签，标签带图标，用不同的颜色标识。&lt;/p&gt;

&lt;p&gt;每完成一个子module，点击勾选，表示完成，可以撤销勾选，表示又重新打开了。&lt;/p&gt;

&lt;p&gt;子module回车即表示该行的修改完成。&lt;/p&gt;

&lt;p&gt;子module中的notes要定时保存到localStorage里，避免丢失。&lt;/p&gt;

&lt;p&gt;这个页面定时向服务器发送请求保存数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定时发送邮件功能&lt;/p&gt;

&lt;p&gt;设定时间，设定发件邮件、收件人、抄送人，整理下格式，就可以放心的发出去了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;分析需求&#34;&gt;分析需求&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>谈谈动/静态类型和强/弱类型</title>
      <link>http://localhost:1313/miscs/static-dynamic-strong-weak-types-of-language/</link>
      <pubDate>Sat, 09 Jan 2016 21:11:33 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/miscs/static-dynamic-strong-weak-types-of-language/</guid>
      <description>&lt;p&gt;作为一个PHP程序员，这个问题本来不应该是我考虑的。
我需要知道仅仅是如果我的程序需要接受一个integer作为输入，拿到输入后最好能&lt;code&gt;intval($var)&lt;/code&gt;一下，保证输入的是integer。而让我感到不理解的是，为什么PHP的强制类型转换会做成&lt;code&gt;(int)$var&lt;/code&gt;这种方式，按照正常人的理解，不管&lt;code&gt;int/string&lt;/code&gt;是关键字还是函数，要么作为&lt;code&gt;int $var&lt;/code&gt;，这样具有迷惑性，因为在别的语言里这都是用来&lt;strong&gt;声明变量&lt;/strong&gt;的，要么&lt;code&gt;int($var)&lt;/code&gt;，这都很容易理解，然而。。。&lt;/p&gt;

&lt;p&gt;好了，想到这个问题是因为这两天算是深入的用了Python的一些功能，当然主要还是用来处理日志，当我发现当我将两个从&lt;code&gt;dict&lt;/code&gt;中取出的值相加，然后和一个数字的值对比时，并没有出现我要的结果。于是就查了下Python的类型。原来Python是&lt;strong&gt;动态类型&lt;/strong&gt;，同时是&lt;strong&gt;强类型&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我看到网上很多人对这个问题还挺迷惑。刚看了PHP对于类型的解释，其实很能说明问题。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;PHP 在变量定义中不需要（或不支持）明确的类型定义；变量类型是根据使用该变量的上下文所决定的。也就是说，如果把一个 &lt;code&gt;string&lt;/code&gt; 值赋给变量 &lt;code&gt;$var&lt;/code&gt;，&lt;code&gt;$var&lt;/code&gt; 就成了一个 &lt;code&gt;string&lt;/code&gt;。如果又把一个&lt;code&gt;integer&lt;/code&gt; 赋给 &lt;code&gt;$var&lt;/code&gt;，那它就成了一个&lt;code&gt;integer&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这，就是标准的动态类型了。相应的，&lt;code&gt;var a = 20 :Int&lt;/code&gt;，声明了变量&lt;code&gt;a=20&lt;/code&gt;，同时指定该变量的类型是&lt;code&gt;Int&lt;/code&gt;，如果&lt;code&gt;var a = &#39;20&#39;: Int&lt;/code&gt;在编译时就会报错，没错这就是静态类型（这是Swift的语法）。有人可能就会拿这个举例说C也是静态类型——的确，我也会认为它是静态类型，因为它也需要指定类型才可以定义——然而，判断是否是静态类型的根据并不在此，而是像&lt;a href=&#34;https://www.zhihu.com/question/19918532#answer-18824124&#34;&gt;知乎@姚培森的答案&lt;/a&gt;中说的，是根据它是否所有程序都是&lt;strong&gt;well behaved&lt;/strong&gt;。这个就太深了，我就不深究了，毕竟对C的研究也不深，说错了还不如不说。&lt;/p&gt;

&lt;p&gt;那再来看看让我误解的Python，无疑，Python和PHP一样在定义变量时也是不需要指定的，但对PHP来说，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$a = 1;
$b = &#39;2&#39;;
echo $a + $b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的代码完全没有问题。但到了Python这里&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = 1
b = &#39;2&#39;
print(a + b) # 没错，我选择Python3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果呢:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Trt recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是强类型和弱类型的区别了。强类型不允许出现&lt;strong&gt;forbidden behaviors&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;从这一点也就可以理解为什么Python的JIT很早前就做出来了，而前段时间鸟哥还在说之前尝试做过PHP的JIT，但发现难度太大，而现在的PHP7实际就是在为后面的JIT铺路呢。&lt;/p&gt;

&lt;p&gt;但让我不解的是既然Python都在这方面占了优势了，为什么还是性能不行呢？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP单元测试-01</title>
      <link>http://localhost:1313/php/2015-09-22-PHP%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-01/</link>
      <pubDate>Tue, 22 Sep 2015 15:49:52 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/2015-09-22-PHP%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-01/</guid>
      <description>

&lt;p&gt;我自认对这种比较系统的知识总是比较欠缺，所以还是花点时间补充上比较好。&lt;/p&gt;

&lt;p&gt;这里说一下PHP的单元测试。&lt;/p&gt;

&lt;p&gt;首先是搭建可以进行单元测试的环境，这里我首选的还是Debian Sid。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install phpunit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一条命令就可以安装单元测试所需要的各种依赖了，之所以选择这种可能不是最新的包的安装方式是因为pear(pecl)在国内的访问速度毕竟不怎么理想，既然我们有一个优秀的&lt;code&gt;apt&lt;/code&gt;了，何必还要费那劲呢？&lt;/p&gt;

&lt;h2 id=&#34;初识单元测试&#34;&gt;初识单元测试&lt;/h2&gt;

&lt;p&gt;首先，一个类对应一个测试类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── FrostWong.php
└── FrostWongTest.php

0 directories, 2 files
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// FrostWong.php

&amp;lt;?php

class FrostWong
{
    public function sayHi()
    {
        return &amp;quot;Hi, UnitTest.\n&amp;quot;;
    }

    public function altb($a, $b)
    {
        return $a &amp;gt; $b;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// FrostWongTest.php

&amp;lt;?php

require &#39;PHPUnit/Autoload.php&#39;;
require &#39;FrostWong.php&#39;;

class FrostWongTest extends PHPUnit_Framework_TestCase
{
    public function testSayHi()
    {
        $fw = new FrostWong();
        $this-&amp;gt;assertEquals(&amp;quot;Hi, UnitTest.\n&amp;quot;, $fw-&amp;gt;sayHi());
    }

    public function testAltb()
    {
        $fw = new FrostWong();
        $this-&amp;gt;assertTrue($fw-&amp;gt;altb(4, 3));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，就可以执行单元测试了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;phpunit FrostWongTest&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个命令有几个需要注意的问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;命令行参数是&lt;code&gt;FrostWongTest&lt;/code&gt;而不是&lt;code&gt;FrostWongTest.php&lt;/code&gt;，这一点和命令行用&lt;code&gt;java&lt;/code&gt;执行&lt;code&gt;class&lt;/code&gt;文件时有异曲同工之妙：）。&lt;/li&gt;
&lt;li&gt;PHP执行包含路径的问题，检查你的&lt;code&gt;php.ini&lt;/code&gt;文件，看其中&lt;code&gt;include_path&lt;/code&gt;一行，看其中有没有包含&lt;code&gt;.&lt;/code&gt;，也就是当前路径。如果不包含，那么执行上面的语句时就会出现&lt;code&gt;Cannot open file FrostWongTest.php&lt;/code&gt;的错误，然后什么都不会发生。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;setup&#34;&gt;setUp&lt;/h2&gt;

&lt;p&gt;你一定也注意到了，因为被测试的类中有两个方法，所以就初始化了两次&lt;code&gt;FrostWong&lt;/code&gt;类，PHPUnit当然给我们提供了更好的方式，那就是&lt;code&gt;setUp&lt;/code&gt;，我理解的&lt;code&gt;setUp&lt;/code&gt;就是一个用来初始化需要的变量的模板方法。同样的还有&lt;code&gt;tearDown&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;所以上面测试用例的第二版就是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

require &#39;PHPUnit/Autoload.php&#39;;
require &#39;FrostWong.php&#39;;

class FrostWongTest extends PHPUnit_Framework_TestCase
{
    function setUp()
    {
        $this-&amp;gt;fw = new FrostWong();
    }

    public function testSayHi()
    {
        $this-&amp;gt;assertEquals(&amp;quot;Hi, UnitTest.\n&amp;quot;, $this-&amp;gt;fw-&amp;gt;sayHi());
    }

    public function testAltb()
    {
        $this-&amp;gt;assertTrue($this-&amp;gt;fw-&amp;gt;altb(4, 3));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，现在你一定已经对PHP端单元测试有了大致的印象了，下一篇会讲一些常用的&lt;code&gt;assert&lt;/code&gt;方法，来进行实际的操练。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
