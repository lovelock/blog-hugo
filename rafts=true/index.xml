<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Me &amp; Web</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Me &amp; Web</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>frostwong@gmail.com (Frost Wong)</managingEditor>
    <webMaster>frostwong@gmail.com (Frost Wong)</webMaster>
    <copyright>(c) 2013-2016 Frost Wong. All rights reserved.</copyright>
    <lastBuildDate>Thu, 22 Sep 2016 14:16:06 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>slf4j配合log4j来给你的应用打log</title>
      <link>http://localhost:1313/java/use-slf4j-and-log4j-to-log-your-applications/</link>
      <pubDate>Thu, 22 Sep 2016 14:16:06 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/java/use-slf4j-and-log4j-to-log-your-applications/</guid>
      <description>&lt;p&gt;需要添加的dependencies&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.21&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.21&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面两个依赖并不是必需的，只需要第一个即可
这时候会发现无穷无尽的warn&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log4j:WARN No appenders could be found for logger (HelloWorld).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但可惜的是即使看了这篇FAQ，也还是不知道是怎么回事&lt;/p&gt;

&lt;p&gt;最简单的办法是需要在main里面新建一个目录&lt;code&gt;resources&lt;/code&gt;，新建文件log4j.properties，写入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log4j.rootLogger=TRACE, file, stdout


log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS} %-5p [%c] - %m%n


log4j.appender.file=org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/javavillage.log
log4j.appender.file.MaxFileSize=10000KB
log4j.appender.file.MaxBackupIndex=10
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%t] %-5p:: %m%n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;todo 需要研究一下&lt;code&gt;log4j.appender.file.File&lt;/code&gt;的根目录是哪里，看起来好像是classpath，但写一个点就会变成当前目录（项目根目录）
再重新编译，happy coding&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用maven创建和运行Java应用</title>
      <link>http://localhost:1313/java/create-and-run-java-application-with-maven/</link>
      <pubDate>Thu, 22 Sep 2016 14:15:41 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/java/create-and-run-java-application-with-maven/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;创建应用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为我最近的使用场景是创建一个普通项目（区别于Web项目），所以直接用&lt;code&gt;mvn archetype:generate&lt;/code&gt;根据提示如果默认一路点下来会生成一个简单应用的骨架。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：如果你在哪里看到&lt;code&gt;mvn archetype:create&lt;/code&gt;这样的写法，而在你的机器上执行出错，不用怀疑，因为你看到的资料太老了，而你用的是新版的maven，按我的写法没有错。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果需要生成webapp类型应用，比如一个机遇SpringFramework的应用就不是831了，而是类似这样&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn archetype:generate -DarchetypeArtifactId=maven-archetype-webapp\
                        -DinteractiveMode=false \
                        -DgroupId=com.unixera.webapp \
                        -DartifactId=spring-example
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;打包应用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般需要把应用和它的依赖打到同一个包里面，所以就需要配置jar-with-dependencies
然后配置一下execute single&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;执行应用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;java -cp $CLASSPATH -jar /path/to/jar-with-dependencies.jar&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;mvn生成的还需要在pom.xml中配置主class&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DeepinLinux体验报告</title>
      <link>http://localhost:1313/linux/deepin-linux-experience/</link>
      <pubDate>Sat, 03 Sep 2016 17:20:45 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/linux/deepin-linux-experience/</guid>
      <description>

&lt;h2 id=&#34;为什么要写这篇文章&#34;&gt;为什么要写这篇文章&lt;/h2&gt;

&lt;p&gt;今天忽然看到知乎上的通知，发现两年前写的一篇答案现在还有人在关注和评论&lt;a href=&#34;https://www.zhihu.com/question/19694358/answer/26227403?group_id=748099576984006656#comment-158674705&#34;&gt;有人用国产的deepin吗？和其它Linux版本相比，有什么优点和不足呢？&amp;ndash;郁蓝的答案&lt;/a&gt;。也是无意间看到了有人让我再更新一下体验的要求（其实这个评论是很早之前的了，只不过今天刚注意到）。
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814221945.png&#34; alt=&#34;知乎答案评论截图&#34; /&gt;
虽然我也不是什么大神，但从我个人的感情来说，我还是很希望深度能做的更好的，所以就花了几个小时真的感受了一下。下面是我认为还比较中肯的看法。&lt;/p&gt;

&lt;h2 id=&#34;体验&#34;&gt;体验&lt;/h2&gt;

&lt;h3 id=&#34;1-官方网站-https-www-deepin-org&#34;&gt;1. &lt;a href=&#34;https://www.deepin.org/&#34;&gt;官方网站&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&#34;华而不实&#34;&gt;华而不实&lt;/h4&gt;

&lt;p&gt;不得不说，这个网站初看上去还是挺好看的，但实际一看就是一个展示页，而且有相当的&lt;strong&gt;应付了事&lt;/strong&gt;的成分。那个国际排名也多少有点忽悠的感觉。。。
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814225102.png&#34; alt=&#34;深度官网展示&#34; /&gt;
因为对细节的展示很少，文档也是七零八碎，像我这样阅发行版无数的人当然很快就找到了安装方法（其实也没有找，只是按照经验），但对于完全不懂Linux的新手来说，很可能看一下就撤了。&lt;/p&gt;

&lt;h4 id=&#34;功能缺失&#34;&gt;功能缺失&lt;/h4&gt;

&lt;p&gt;即便这样，我觉得很多我关心的信息在网站上都没有展示出来。我是一名软件开发人员，说的更笼统一些是一名上班族，那从一个上班族的角度来看，如果要我从Windows迁移到Deepin OS，我会关注哪些东西？当然是办公软件的使用。这个&lt;strong&gt;办公软件&lt;/strong&gt;是广义上的，包括&lt;strong&gt;QQ,RTX,Office,搜狗输入法，邮件&lt;/strong&gt;等等，这个问题，产品经理肯定想过，因为我用了之后发现确实他们已经解决了，但在页面上并没有展示出来。甚至，我的希望是&lt;strong&gt;在页面上能有一个搜索框，我在安装之前就能知道哪些软件我能用，让我不会产生后顾之忧&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&#34;细节不到位&#34;&gt;细节不到位&lt;/h4&gt;

&lt;p&gt;我甚至点到了社区板块，看了一下更新日志，比如这篇&lt;a href=&#34;http://blog.deepin.org/2016/08/update-record-of-applications-in-deepin-store-2016-08/&#34;&gt;深度商店应用更新记录汇总2016-08&lt;/a&gt;。这样的汇总我实在是不想看，感觉就像是用awk+xargs处理了一下只把应用名打印出来的样子。我看到了两个问题：
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814225410.png&#34; alt=&#34;社区网页展示&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- 没有版本号，**差评**
- 应用名太拥挤，看起来不直观
- 层级不能回退，都实现成这样的控件竟然不能点击，简直不能忍
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我看到右侧其实是又很多这种更新汇总的，我觉得这作为一个正常人是都能看得到的问题，但就是不知道为什么那么久了都还一直这样。这期的我看到下面又评论说到没有版本号的事情，管理员（不知道是不是）说下次会带上。&lt;/p&gt;

&lt;h4 id=&#34;小结&#34;&gt;小结&lt;/h4&gt;

&lt;p&gt;总的感觉就是&lt;strong&gt;华而不实&lt;/strong&gt;，对细节的考虑不到位，简直浪费了程序员们的辛苦劳动。东西再好，展示的窗口都不做好，怎么吸引人呢？我觉得要么就传统一些，做一个像&lt;a href=&#34;https://www.archlinux.org/&#34;&gt;ArchLinux官网&lt;/a&gt;那样的纯展示性网站，引导用户去一个完备的Wiki站点，要么就学一学现在的手机厂商，把现代化的网页做的详细一些，别让用户费了半天劲把页面从最上面拉到最下面了却发现什么也没看明白。&lt;/p&gt;

&lt;h3 id=&#34;1-安装直观感受&#34;&gt;1. 安装直观感受&lt;/h3&gt;

&lt;p&gt;没有LiveCD，差评。
很不理解的一点，我刻好了优盘启动盘准备先在LiveCD里体验一下，看到启动项只有一个&lt;strong&gt;Start installation&lt;/strong&gt;我就懵逼了。。。这是跟国产的流氓软件学的，不让尝，先买了再说么？&lt;/p&gt;

&lt;h3 id=&#34;2-缺点&#34;&gt;2. 缺点&lt;/h3&gt;

&lt;p&gt;整个安装界面就有些搞不清楚。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有保留像Ubuntu那样可以&lt;strong&gt;对用户透明的和其他系统共存&lt;/strong&gt;的功能。（貌似最近的这版从基于Ubuntu迁移到了Debian Sid，这样就可以解释了，关于迁移的事情后面会说）&lt;/li&gt;
&lt;li&gt;对高清屏的支持不好，这在上面的截图里都已经可以看到了，我的电脑是15寸1080P屏幕，显示的字体太小，伤眼睛&lt;/li&gt;
&lt;li&gt;选择完语言之后就没得回去了，只能往后，不能往前，这有点蛋疼&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好在安装过程很顺利，也很快。这点很赞。&lt;/p&gt;

&lt;h3 id=&#34;3-亮点&#34;&gt;3. 亮点&lt;/h3&gt;

&lt;p&gt;吐槽完了也得有点亮点吧，也不旺我把Ubuntu分区都干掉装这个啊。界面风格没啥好说的，还提供了三种模式
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814180441.png&#34; alt=&#34;默认Dock模式&#34; /&gt;
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814230948.png&#34; alt=&#34;Windows Dock模式1&#34; /&gt;
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814231109.png&#34; alt=&#34;Windows Dock模式2&#34; /&gt;
看完上面三张图，你有什么感受？对，没有自己的灵魂，学谁都没学像。学苹果却没有Magic动画，学Windows又没有开始菜单。而且控制面板放在最右边是什么鬼？是为了适应触摸屏？模仿Windows8的交互？看吧，Windows10已经回归了，我估计这个控制面板也要改成传统模式了。
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814231725.png&#34; alt=&#34;控制面板&#34; /&gt;&lt;/p&gt;

&lt;p&gt;说了这些发现还是吐槽，真正的亮点在终端。貌似是修改版的Quake，但我可没有在Quake里面找到过这个功能，简直贴心。
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814232511.png&#34; alt=&#34;SSH管理功能&#34; /&gt;
试了一下，简直弱鸡啊，也仅仅是个管理，连私钥都不支持。好吧，完成度不高，忍了。&lt;/p&gt;

&lt;p&gt;应用商店的资源还是挺丰富的，常用的差不多都有——其实本来Gnome也都有了。重点在于深度为用户提供了几乎0成本使用QQ的机会，这点很重要，一直以来对中国用户来说，Linux最大的痛点不就是没有QQ么？
其他软件也是开箱即用，完整度还可以，但完成度有待提高。&lt;/p&gt;

&lt;h3 id=&#34;4-混乱&#34;&gt;4. 混乱&lt;/h3&gt;

&lt;p&gt;整个一下午用下来最大的感受就是&lt;strong&gt;混乱&lt;/strong&gt;，看起来深度桌面更像是基于Gnome的，也带了不少Gnome系的应用，但它其实又在Gnome的基础上加上了自己的想法，让体验变得更加不统一了。比如应用打开首选项的方式和图标都不统一，有些按钮的位置那是真隐晦，谁能看出来那是按钮我服谁。
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/DeepinScreenshot20160814235541.png&#34; alt=&#34;界面高度不统一&#34; /&gt;
至于其中的某些Qt的应用带了的体验不一致这里就不说了，目前也没什么好的解决办法。&lt;/p&gt;

&lt;h3 id=&#34;5-期望&#34;&gt;5. 期望&lt;/h3&gt;

&lt;p&gt;总的来说，功能做的还是不错的，因为加入了Windows上常用的软件，使得它基本上算是一个开箱即用的操作系统。尤其是搜狗输入法的加成，让它对普通用户的友好程度大增。我搜了一下，软件源里面是包含Jetbrains家的应用的。只不过版本比较老了而已。看起来也没有对其进行什么修改，不知道是什么耽搁了它和上游的同步。现在这个Quake的SSH管理功能太弱鸡，如果可以，我希望能把Windows上的XShell引进来，毕竟Mac和Linux上都没有一款这么好用的终端。&lt;/p&gt;

&lt;p&gt;总之，深度的这款操作系统还是很能解决中国人用Linux的痛点的，这些痛点真的不是加个天气软件和农历日历就能解决的。很多使用习惯的问题需要去引导和克服。有人说，有这闲工夫通过各种技术手段让Windows上的软件跑在Linux上还不如大力发展Linux的原生应用，简直是Naive，如果原生的这么好做，也就不会有CrossOver这样的收费软件了。这毕竟是软件提供商的问题，他们不重视，作为用户也只能想别的办法了，起码在目前看来，这种方式是最行之有效又一针见血的。&lt;/p&gt;

&lt;p&gt;我想提的建议是，产品经理要是没什么大问题的话就换了吧，现在的真心不称职。包括网站的和桌面端的，抄别人的东西都抄不到精髓，那只能说自己都不知道想抄什么。那壁纸怎么那么像一加天气的背景呢？看我还是个耿直的boy，一加的ROM不行，确实是开发不给力，而Deepin做不好，产品要负大部分责任。&lt;/p&gt;

&lt;p&gt;感谢深度在Linux国产化的进程中的突出贡献。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>给Java新手看的mvn指南</title>
      <link>http://localhost:1313/java/mvn-tutorial-for-novice/</link>
      <pubDate>Sun, 28 Aug 2016 14:29:16 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/java/mvn-tutorial-for-novice/</guid>
      <description>

&lt;h2 id=&#34;官方定义&#34;&gt;官方定义&lt;/h2&gt;

&lt;p&gt;Maven是基于项目对象模型，可以通过一小段描述信息来管理项目的构建、报告和文档的软件管理工具。&lt;/p&gt;

&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;Maven的使用过程中最经常用到的就是依赖管理了，一个依赖也就是一个包，是包含了几个属性的
- &lt;code&gt;groupId&lt;/code&gt; 通常是公司域名的反写加上项目名，比如&lt;code&gt;com.unixera.mvndemo&lt;/code&gt;
- &lt;code&gt;artifactId&lt;/code&gt; 模块名，比如&lt;code&gt;project1&lt;/code&gt;
- &lt;code&gt;version&lt;/code&gt; 版本号，经常见到的是形如&lt;code&gt;1.0.0-SNAPSHOT&lt;/code&gt;这种，即快照版本，还有&lt;code&gt;RELEASE&lt;/code&gt;等。&lt;/p&gt;

&lt;h2 id=&#34;规定&#34;&gt;规定&lt;/h2&gt;

&lt;p&gt;它规定的目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-src 
 -main
  -java
   -packagename
 -test
  -java
   -packagename
 -resource
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基础命令&#34;&gt;基础命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mvn compile&lt;/code&gt; 编译项目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mvn test&lt;/code&gt; 测试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mvn package&lt;/code&gt; 打包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mvn clean&lt;/code&gt; 删除已经生成的测试报告和字节码文件，其实就是删除target文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mvn install&lt;/code&gt; 安装jar包到本地目录中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面这5个过程如果执行后面的，前面的也会自动执行。也就是说后面的命令是依赖前面的命令的。&lt;/p&gt;

&lt;h2 id=&#34;经常遇到的问题&#34;&gt;经常遇到的问题&lt;/h2&gt;

&lt;h3 id=&#34;1-间接依赖&#34;&gt;1. 间接依赖&lt;/h3&gt;

&lt;p&gt;A依赖B，B依赖C，那么A就间接的依赖了C，如果要显式的声明A不依赖C，可以在A的pom.xml中加入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;
&amp;lt;dependecy&amp;gt;
	&amp;lt;groupId&amp;gt;BgroupId&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;BartifactId&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
	&amp;lt;exclusions&amp;gt;
		&amp;lt;exclusion&amp;gt;
			&amp;lt;groupId&amp;gt;CgroupId&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;CartifactId&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
		&amp;lt;/exclusion&amp;gt;
	&amp;lt;/exclusions&amp;gt;
&amp;lt;/dependecy&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-如何添加依赖&#34;&gt;2. 如何添加依赖&lt;/h3&gt;

&lt;p&gt;比如项目要使用servlet，那就去&lt;a href=&#34;http://search.maven.org/&#34;&gt;全球中央仓库&lt;/a&gt;查找包名和相应的版本号,如图所示&lt;img src=&#34;http://ww4.sinaimg.cn/large/7853084cjw1f79btj2nb8j20fl0f9q4b.jpg&#34; alt=&#34;&#34; /&gt;。从中复制Apache Maven下面的一段XML粘贴到相应的&lt;code&gt;&amp;lt;dependencies&amp;gt;&amp;lt;/dependencies&amp;gt;&lt;/code&gt;中即可。&lt;/p&gt;

&lt;h3 id=&#34;3-变量的使用&#34;&gt;3. 变量的使用&lt;/h3&gt;

&lt;p&gt;有时在一个pom.xml文件中会看到有&lt;code&gt;${project.version}&lt;/code&gt;这种写法，那一看就是一个引用，这个东西是在&lt;code&gt;&amp;lt;properties&amp;gt;&amp;lt;/properties&amp;gt;&lt;/code&gt;中定义的，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;properties&amp;gt;
    &amp;lt;maven.compile.source&amp;gt;1.5&amp;lt;/maven.compile.source&amp;gt;
    &amp;lt;maven.compile.target&amp;gt;1.5&amp;lt;/maven.compile.target&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样定义了之后在后面就可以用&lt;code&gt;${maven.compile.source}&lt;/code&gt;来引用了。&lt;/p&gt;

&lt;h3 id=&#34;4-一个项目下多个模块重复依赖一个包&#34;&gt;4. 一个项目下多个模块重复依赖一个包&lt;/h3&gt;

&lt;p&gt;下面着重说一下如何利用Maven的继承关系简化项目的POM配置。&lt;/p&gt;

&lt;h4 id=&#34;在项目的根目录下创建pom-xml&#34;&gt;在项目的根目录下创建pom.xml&lt;/h4&gt;

&lt;p&gt;还以上面的项目名为例，比如root目录是project,则在project目录里创建pom.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
	xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
	&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
	&amp;lt;groupId&amp;gt;com.unixera&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;root&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
	&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
	
	&amp;lt;properties&amp;gt;
	    &amp;lt;project.version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/project.version&amp;gt;
	    &amp;lt;junit.version&amp;gt;4.10&amp;lt;/junit.version&amp;gt;
	    &amp;lt;jmock.version&amp;gt;2.8.2&amp;lt;/jmock.version&amp;gt;
	&amp;lt;/properties&amp;gt;
	
	&amp;lt;dependencies&amp;gt;
	    &amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;${junit.version}&amp;lt;/version&amp;gt;
			&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.jmock&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jmock&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${jmock.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
	&amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就声明了该项目需要依赖junit，那么里面的子项目就用&lt;code&gt;mvn archetype:generate&lt;/code&gt;来交互式的生成，比如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Choose org.apache.maven.archetypes:maven-archetype-quickstart version:
1: 1.0-alpha-1
2: 1.0-alpha-2
3: 1.0-alpha-3
4: 1.0-alpha-4
5: 1.0
6: 1.1
Choose a number: 6: 6
Define value for property &#39;groupId&#39;: : com.unixera.mvndemo
Define value for property &#39;artifactId&#39;: : project1
Define value for property &#39;version&#39;:  1.0-SNAPSHOT: :
Define value for property &#39;package&#39;:  com.unixera.mvndemo: :
Confirm properties configuration:
groupId: com.unixera.mvndemo
artifactId: project1
version: 1.0-SNAPSHOT
package: com.unixera.mvndemo
 Y: :
[INFO] ----------------------------------------------------------------------------
[INFO] Using following parameters for creating project from Old (1.x) Archetype: maven-archetype-quickstart:1.1
[INFO] ----------------------------------------------------------------------------
[INFO] Parameter: basedir, Value: /Users/frost/IdeaProjects
[INFO] Parameter: package, Value: com.unixera.mvndemo
[INFO] Parameter: groupId, Value: com.unixera.mvndemo
[INFO] Parameter: artifactId, Value: project1
[INFO] Parameter: packageName, Value: com.unixera.mvndemo
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] project created from Old (1.x) Archetype in dir: /Users/frost/IdeaProjects/project1
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 35.492 s
[INFO] Finished at: 2016-08-28T14:16:28+08:00
[INFO] Final Memory: 13M/201M
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入&lt;code&gt;project&lt;/code&gt;目录，打开&lt;code&gt;pom.xml&lt;/code&gt;，可以看到mvn生成的项目已经默认依赖了junit，那我们来修改一下让它依赖parent所定义的junit。
首先加上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;parent&amp;gt;
	&amp;lt;groupId&amp;gt;com.unixera.mvdemo&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;root&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以把junit的依赖放心的删掉了，因为它已经认了root做parent，parent的依赖就是它的依赖了。&lt;br /&gt;
那如果parent的某些依赖它并不需要呢？可以在子项目中添加&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencyManagement&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.unixera.mvndemo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;root&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.jmock&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;jmock&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;2.8.2&amp;lt;/version&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样子项目就不依赖jmock模块了。&lt;/p&gt;

&lt;p&gt;当然mvn的使用远远不止这些，这里记录一些目前使用到的，后面如果还继续回写Java的话会再更新一下。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用ssh-config提升你的生产力</title>
      <link>http://localhost:1313/mac/use-ssh-config-to-tune-your-productivity-up/</link>
      <pubDate>Tue, 09 Aug 2016 14:57:11 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/mac/use-ssh-config-to-tune-your-productivity-up/</guid>
      <description>

&lt;p&gt;我们做服务端开发的，每天最烦心的事情可能就是登陆各种服务器了。在Windows上还好，有SecureCRT还有XShell这种很强大的工具可以用，但在Mac下面选择就很少了。SecureCRT我个人感觉远远不如Windows下的稳定，而渲染效果我当然还是最喜欢iTerm了。其实并没有用到它的很强大的那些功能，比如窗口分割、全局查找等等，最能打动我的其实是智能复制粘贴。不多说了，下面说一下怎样用ssh的config文件来记住登录账户。&lt;/p&gt;

&lt;h2 id=&#34;常规的解决方案&#34;&gt;常规的解决方案&lt;/h2&gt;

&lt;p&gt;我们最习惯用已知的知识来解决新问题。所以当然你会在.bashrc中添加一条&lt;code&gt;alias dev=&#39;ssh root@10.69.41.41&#39;&lt;/code&gt;这种命令了——注意，这个指令在多数环境中其实是不适用的，因为还面临通道机——最让开发头痛的东西。&lt;/p&gt;

&lt;p&gt;所以让我们来发掘一下ssh的强大威力。&lt;/p&gt;

&lt;h2 id=&#34;用ssh-config提高效率&#34;&gt;用ssh config提高效率&lt;/h2&gt;

&lt;h3 id=&#34;可以直连的机器&#34;&gt;可以直连的机器&lt;/h3&gt;

&lt;p&gt;如果可以直连一台机器，比如我的192.168.1.104虚拟机，那就可以在&lt;code&gt;.ssh/config&lt;/code&gt;中添加一段记录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host debian
	Hostname 192.168.1.104
	Port 22
	User frost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不需重启，现在执行&lt;code&gt;ssh debian&lt;/code&gt;就可以连接debian机器了。&lt;br /&gt;
那么问题来了，通常来说，Linux环境中是找不到明文存储的密码的，这里也不例外，肯定不会让你把密码直接写在这个配置文件中。要实现重新打开一个标签连接同一台机器不需要重新输密码，有两种方式。&lt;/p&gt;

&lt;h4 id=&#34;1-用key登录&#34;&gt;1. 用key登录&lt;/h4&gt;

&lt;p&gt;具体操作这里不展开，这里只需要把key的路径加在配置文件里即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host debian
	Hostname 192.168.1.104
	IdentityFile ~/.ssh/coolio.example.key
	Port 22
	User frost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可。这是最简单直接的方式。&lt;/p&gt;

&lt;h4 id=&#34;2-模拟securecrt的-复制会话-功能&#34;&gt;2. 模拟SecureCRT的『复制会话』功能&lt;/h4&gt;

&lt;p&gt;也就是说，在一个标签登录了一台机器之后，会在本地保存一份该会话的标识文件。当重新连接这个机器时，会使用这个临时文件当做认证，直接登录而无需验证。局限是如果重启了终端，就需要重新输入一次密码。&lt;br /&gt;
要实现这个功能，只需要在&lt;code&gt;.ssh/config&lt;/code&gt;里加入这样一段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host *
ControlMaster auto
ControlPath ~/.ssh/master-%r@%h:%p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能要问了，key那么方便，为什么需要这样呢？这是因为我们认为key已经很安全了，但安全组的同事可能觉得也没那么安全，他们希望我们用安全性更高的静态密码+动态口令的方式登录跳板机，而且跳板机是无法存储任何文件的，无法实现保存key。&lt;/p&gt;

&lt;h3 id=&#34;无法直连的机器&#34;&gt;无法直连的机器&lt;/h3&gt;

&lt;p&gt;前面提到了跳板机，登录到跳板机当然不是目的，还要登录各种各样的机器，如果我要经常登录一台跳板机后的机器，难道要每次都先登录跳板机（虽然不用每次都输入密码）然后再手工跳转到另一台机器？当然不是。这里要引入『本地端口转发』的概念。
说白了就是我们指定一个本地端口，往这个端口发送的所有数据都会通过&lt;strong&gt;跳板机&lt;/strong&gt;被转发到另外一台机器的指定端口。注意两个指定端口不需要是一样的。比如我希望通过本地的2222端口来登录一台开发机的22端口。就需要这样配置一个隧道&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host tunnel
	HostName 10.0.0.2
	LocalForward 2222 10.30.43.23:22
	User frost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样执行&lt;code&gt;ssh -f -N tunnel&lt;/code&gt;就会建立这条本地端口转发的隧道。其实还需要一段配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host dev
	HostName 127.0.0.1
	Port 2222
	User root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，看到&lt;code&gt;ssh -f -N tunnel&lt;/code&gt;这条这么长的指令还是不爽，这时就可以用alias来简化输入了。&lt;/p&gt;

&lt;h3 id=&#34;服务器和本地传输文件&#34;&gt;服务器和本地传输文件&lt;/h3&gt;

&lt;p&gt;其实用SecureCRT或者XShell还有一个很重要的原因是二者对lrzsz这个小工具的支持很好，而几乎所有的终端工具都存在各种问题，iTerm2也不例外。虽然也可以有workaround来解决，但毕竟不是原生，不好用。我也纠结了很久，原来Mac上没有相应的工具是因为真的不需要啊。&lt;br /&gt;
现在跟我一起做，比如我们前面已经配了一个可以本地直连的远程机器debian，当需要传输文件的时候只需要在本地命令窗口打开&lt;code&gt;sftp debian&lt;/code&gt;就会打开一个交互的shell。那么不要怕，虽然它有很多命令，但我觉得简单的使用只需要记住4组命令就好了，而且其中3组是原来就会的。&lt;br /&gt;
首先要知道本地和远程的概念，因为你执行了这个命令之后其实已经登陆了了远程机器了，只不过不在bash里面，所以现在你要操作本地的东西时，所有命令都要加上&lt;code&gt;l&lt;/code&gt;也就是local，而远程的就什么都不加了。&lt;br /&gt;
所以记住下面几个命令：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;lpwd&lt;/code&gt; 查看本地机器当前所在目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pwd&lt;/code&gt; 查看远程机器当前所在目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lls&lt;/code&gt; 查看本地机器当前目录下的文件列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls&lt;/code&gt; 查看远程机器当前目录下的文件列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lcd dir&lt;/code&gt; 在本地切换到目标目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd dir&lt;/code&gt; 在远程主机上切换到目标目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;put filename&lt;/code&gt; 把本地的文件放在远程主机的当前位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get filename&lt;/code&gt; 把远程机器上的目录下载到本地当前位置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这和SecureCRT的实现方式是完全一样的，XShell好封装了一个两栏的文件管理器呢，这样看来XShell真的是业界良心。&lt;/p&gt;

&lt;p&gt;有人可能会说用expect来实现密码自动填充也是极好的。这个问题，见仁见智吧，至少用了一段时间之后我是不喜欢用expect了，最主要的问题在于窗口的自动缩放，就不展开说了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>谈谈转基因食物</title>
      <link>http://localhost:1313/miscs/talk-about-transgene-foods/</link>
      <pubDate>Sun, 17 Jul 2016 22:53:33 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/miscs/talk-about-transgene-foods/</guid>
      <description>&lt;p&gt;这件事情其实我没有怎么关注过，到超市去买油什么的也是全凭一时冲动，没有固定的品牌和品种。&lt;/p&gt;

&lt;p&gt;因为我是生物专业毕业的，知道的人难免会让我谈谈关于转基因食物的看法，因为我并不了解社会上对这件事的主流看法是怎样的，所以在谈这个问题时往往不太敢太明显的表达自己的观点，而会模棱两可的说我认为转基因是无害的，而具体是否是这样，还需要科学家们去证实。&lt;/p&gt;

&lt;p&gt;我觉得任何一个学过高中生物课的人都应该能明白这个道理。我们吃的食物在体内是经过消化和分解过程的。最终吸收到体内的不过是一个个的生物大分子片段，这些片段包括氨基酸，也就是蛋白质的组成结构，当然也有（脱氧）核糖核酸，注意，我说的是片段，因为它们也仅仅是片段，它们的作用是为我们提供营养物质，而不是改变我们身体的性状。&lt;/p&gt;

&lt;p&gt;之所以很多人一提到转基因就害怕，可能是社会上某些公知人士的大肆渲染，毕竟因为自己不懂，对那些认为自己很懂又很愿意宣传，同时很有影响力的人当然大多数人会选择深信不疑。这种盲从很可怕。&lt;/p&gt;

&lt;p&gt;看过我文章的读者可能知道我喜欢用最贴近生活的例子来阐述一件事情。那对于转基因这件事，我还是有个例子可以说。&lt;/p&gt;

&lt;p&gt;转基因可以分为自然转基因和人工转基因。大多数人害怕的其实是『人工转基因』。想理解人工转基因，那就得先知道什么是自然转基因。其实自然转基因在生活中处处可见，比如你家的小狗狗生了一群小小狗狗，小小狗狗的爸爸妈妈都是黑色的，但有可能这群小小狗狗里有一只身上出现了白色的斑点，这就有可能是基因突变引起的。我说有可能是因为关于狗的遗传特性我并没有具体研究，不知道毛色是显性还是隐形性状。咱们单说这个毛色的突变，从基因的层面上说就是有可能小小狗狗的某一条染色体上的F变成了F1,然后它翻译、转码生成的蛋白质就变成了白色。当这只小小狗狗再生小宝宝时，这种白色的性状就有可能保留了下来。假设，在这只小狗之前世界上没有带白色斑点的狗，那么严格的说，我们甚至可以说基因突变『产生』了一种新的性状。&lt;/p&gt;

&lt;p&gt;其实，基因突变就是一种自然转基因的类型。我说它是一种类型，那肯定就还有别的类型，那就是杂交了。别以为只有在人类的干预下才会有杂交的出现，其实自然界中这种现象相当普遍。一般来说生物之间是有自然隔离的，但大自然就是这么神奇，万一两种生物的染色体条数一样多，再加上其他因素也匹配，那么两种生物就有可能杂交而产生一种新的物种。当然我印象中的杂交产物就是骡子了，但骡子是没有繁殖能力的，并不能算是新的物种。&lt;/p&gt;

&lt;p&gt;那对应基因突变和杂交，人工转基因究竟干了什么呢？&lt;/p&gt;

&lt;p&gt;对狭义的转基因（排除杂交）而言，转基因就是把一个物种的DNA上某些片段重新编码成新的序列，从而产生新的性状。（这不是教科书上的定义，可能并不准确，只是我的理解）而产生这种重新编码的方法也有多种，有可能是从其他物种的DNA上截取一截粘贴上去，也可能是直接人工重新排序一段编码，还有最初的用宇宙射线什么的引发基因突变等等，当年学的什么密码子啥玩意儿的都忘得差不多了，只需要知道这些技术现在已经工业化了就对了，根本不是问题。&lt;/p&gt;

&lt;p&gt;想想有点可笑，外面都说我们中国人什么都吃，但到了转基因这里却变得异常谨慎了。&lt;/p&gt;

&lt;p&gt;那么，我就想问了，黑色狗是狗，带斑点的狗还是狗吗？『正常』的大豆是大豆，转基因的大豆就不是大豆了？你吃的转基因豆油大部分只是脂肪而已，到了肚子里是还要经过消化的，它只不过变成了我们需要的各种氨基酸等，并没有让我们的基因重排，并不会改变我们的性状。&lt;/p&gt;

&lt;p&gt;今天还看到微博上自称『央视新闻』的媒体说某些主要成分是『氯化钠』的假冒食盐已经流向市场，长期食用氯化钠可引起头晕等等症状，说的头头是道，我看了好多遍到底说的是不是氯化钠，最后确定还真是，而且这个微博账号确实是官方的。这么说那还不如说『某某生成的劣质水，主要成分是一氧化二氢，大量食用会引起膀胱胀痛』。&lt;/p&gt;

&lt;p&gt;如果你觉得民智没有开启，那么就请尽自己的一份力量多解释一下；如果他们不愿意听，你可以解释给下一个人听，没有必要变得像他们一样，网络上全是乌烟瘴气的对骂，没有意义，而且会让自己显得和他们一样，只是喷子，更没有人愿意听你的真相了。&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>理解PHP的Service Container</title>
      <link>http://localhost:1313/php/understanding-PHP-container/</link>
      <pubDate>Sat, 18 Jun 2016 07:04:22 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/understanding-PHP-container/</guid>
      <description>

&lt;p&gt;前段时间一直在花时间研究依赖注入的问题，现在虽然也没有研究的很透彻，但有了一些很模糊的概念，是时间把它总结一下了，既帮助自己理解，也能给现在还没有理解的同学们一点启发。&lt;/p&gt;

&lt;p&gt;本文将从以下几点展开。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;什么是依赖注入？为什么要有依赖注入？&lt;/li&gt;
&lt;li&gt;什么是Service Container(服务容器）？它和Docker的Container有关系吗？又有什么用？&lt;/li&gt;
&lt;li&gt;以Pimple为例，通过解读源代码来分析实现一个简单的Service Container。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;什么是依赖注入-为什么要有依赖注入&#34;&gt;什么是依赖注入？为什么要有依赖注入？&lt;/h2&gt;

&lt;p&gt;举个最常见到的例子来讲，比如我们的代码分层中有业务逻辑层(Logic层）和数据库操作层(Dao层），那在L层如何调用D层的代码呢？多数情况下可能会像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
&amp;lt;?php

class Sample
{
    private $daoSample;

    public function __construct()
    {
        $this-&amp;gt;daoSample = new DaoSample();
    }

    public function setDao(DaoInterface $dao)
    {
        $this-&amp;gt;daoSample = $dao;
    }
    
    public function newAccount($params)
    {
        $this-&amp;gt;daoSample-&amp;gt;addRecord($params);
    }
}

&amp;lt;?php

class Sample
{
    const TABLE_NAME = &#39;t_Sample&#39;;

    public function addRecord($params)
    {
        echo __METHOD__ . &amp;quot;\n&amp;quot;;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这样的依赖注入，我们在写业务层代码的时候就可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$logicSample = new Logic\Sample();
$logicSample-&amp;gt;newAccount($params);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完全不用考虑用的是什么类型的数据库操在类了，只需要保证它能够完成任务即可。&lt;/p&gt;

&lt;p&gt;这是个极端简化的例子，在实际的工作中，可能会遇到一个类依赖很多个类的情况，如果把每个依赖都写到构造函数里，也不是不可以，但维护起来也是挺麻烦的。&lt;br /&gt;
有一个“看起来”更简单一点的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

class Sample
{
    private $daoSample;

    public function __construct(DaoInterface $dao)
    {
        $this-&amp;gt;daoSample = $dao;
    }

    public function setDao(DaoInterface $dao)
    {
        $this-&amp;gt;daoSample = $dao;
    }
    
    public function newAccount($params)
    {
        $this-&amp;gt;daoSample-&amp;gt;addRecord($params);
    }
}

&amp;lt;?php

class Sample
{
    const TABLE_NAME = &#39;t_Sample&#39;;

    public function addRecord($params)
    {
        echo __METHOD__ . &amp;quot;\n&amp;quot;;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这样在调用的时候就需要这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
$daoSample = new Dao\Sample();
$logicSample = new Logic\Sample($daoSample);
$logicSample-&amp;gt;newAccount($params);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要额外维护底层工具类的初始化。看起来更复杂了，但我觉得“依赖注入容器”的思想恰恰是从这样的用法中通过更深层次的思考得到的。&lt;/p&gt;

&lt;h2 id=&#34;什么是service-container-服务容器-它和docker的container有关系吗-又有什么用&#34;&gt;什么是Service Container(服务容器）？它和Docker的Container有关系吗？又有什么用？&lt;/h2&gt;

&lt;p&gt;我们把像&lt;code&gt;Dao\Sample&lt;/code&gt;这样的类叫做“服务”吧，现在在使用这些服务之前需要自己来管理&lt;strong&gt;服务的初始化&lt;/strong&gt;，那么有没有办法把这个工作托管出去呢？&lt;br /&gt;
最直观的想法可能就是把这些”服务“放在一个容器里，需要的时候直接拿来用就行。那么问题又来了，还是需要先给它初始化，然后才能放在容器里，再多想一步，能不能让容器自己来管理里它的初始化？&lt;/p&gt;

&lt;p&gt;当我需要一个服务时，就取容器里取，如果该服务在容器中定义了，但还没有初始化，那容器就给它初始化，并把这个实例保存下来，下次再有别的地方使用该服务时直接拿来用即可。&lt;/p&gt;

&lt;p&gt;这就是依赖注入容器的理想状态了吧。&lt;/p&gt;

&lt;p&gt;它和Docker的容器当然没有任何关系。&lt;/p&gt;

&lt;p&gt;虽然都叫容器，但它们解决的问题或者说痛点其实是不同的。依赖注入容器解决的是服务随取随用，Docker的容器本质上把一个服务相关的所有东西打包在一起，找到一个宿主机它就能在自己的空间内跑起来，它解决的问题是一次生成，到处运行的问题，从这点上看有点像Java的口号。&lt;/p&gt;

&lt;h2 id=&#34;实现一个简单的service-container&#34;&gt;实现一个简单的Service Container&lt;/h2&gt;

&lt;p&gt;没错，我们是PHP开发者，那我们一定很喜欢数组，对不对？&lt;/p&gt;

&lt;p&gt;好，那我们就来实现一个和数组用起来差不多的依赖注入容器。（主要参考了Pimple的实现）&lt;/p&gt;

&lt;h3 id=&#34;功能设计&#34;&gt;功能设计&lt;/h3&gt;

&lt;h3 id=&#34;api设计&#34;&gt;API设计&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>多人协作场景下的git</title>
      <link>http://localhost:1313/git/git-in-practice/</link>
      <pubDate>Fri, 13 May 2016 22:30:18 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/git/git-in-practice/</guid>
      <description>&lt;p&gt;之前虽然也写了点Git的使用方法，但都是在仅有我自己维护代码的情况下做的，只有master分支，而到了多人协作的场景下，就需要有新的知识补充了。&lt;/p&gt;

&lt;p&gt;首先这个使用场景是这样的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;master分支就是它的原始功能，主干，所有人在分支上的代码在上线之前需要合并到master&lt;/li&gt;
&lt;li&gt;上线是把master再checkout一份&lt;/li&gt;
&lt;li&gt;每个人在自己的分支做开发&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面说下碰到的问题，以&lt;a href=&#34;https://coding.net/u/lovelock/p/learngit/git&#34;&gt;learngit&lt;/a&gt;这个项目为例。&lt;/p&gt;

&lt;p&gt;刚接手一个新项目，clone一份吧&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://git.coding.net/lovelock/learngit.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这时项目目录是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-4.3$ git branch
* master
bash-4.3$ git status
On branch master
Your branch is up-to-date with &#39;origin/master&#39;.
nothing to commit, working directory clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我要开发的功能不能放在master里，所以需要新建一个分支，那可能会有人问为什么不能放在master里。我的理解是&lt;strong&gt;要保持master分支的清洁&lt;/strong&gt;，这体现在每个人在自己分支的提交不会体现在master分支的git log结果里，这里只体现合并到master的信息，这样我们对每次合并做了什么就一目了然，不会出现多余的信息。当然另外一个重要的原因是防止代码冲突，其实解决冲突的还是人，这点就不多说了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout -b feature
bash-4.3$ git checkout -b feature
Switched to a new branch &#39;feature&#39;
bash-4.3$ git branch
* feature
  master
bash-4.3$ git status
On branch feature
nothing to commit, working directory clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从&lt;code&gt;git branch&lt;/code&gt;的输出可以看到，我们现在已经位于feature分支里了。现在所进行的任何修改都将位于feature分支。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-4.3$ touch feature.txt
bash-4.3$ git status
On branch feature
Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

	feature.txt

nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在在新分支创建一个文件，再看status，现在这个文件没有被track，需要把它加进来。&lt;/p&gt;

&lt;p&gt;好，那么问题来了，如果我不想把它加进来呢？我们先说前一种最常见的情况。其实提示信息已经教会我们要怎么做了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-4.3$ git add feature.txt
bash-4.3$ git status
On branch feature
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

	new file:   feature.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里为了严谨，没有用我平时用的&lt;code&gt;git add .&lt;/code&gt;（其实最主要的是切换到了bash，而没有用zsh提供的更方便的git操作)。现在这个新文件正在等待被提交。等等，括号里面的提示是什么东西？它告诉我怎样才能让git 不再track它？对，可以试一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-4.3$ git reset HEAD feature.txt
bash-4.3$ git status
On branch feature
Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

	feature.txt

nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次的输出又和上上一次的一样了。好，既然已经回到了这个状态，下面看怎么让这个文件消失。这个需求我觉得主要用在要在一个项目中做一些编译工作，编译嘛，会产生很多多余的文件，安装完成后也不会消失，我想让这个项目重新回到干净的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-4.3$ git clean -df
Removing feature.txt
bash-4.3$ git status
On branch feature
nothing to commit, working directory clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在工作目录又焕然一新了，如果并不想清除整个目录中的&lt;strong&gt;unstaged&lt;/strong&gt;的文件，可以在这条命令的后面加上路径即可。&lt;/p&gt;

&lt;p&gt;回到前面&lt;code&gt;git add feature.txt&lt;/code&gt;后，执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-4.3$ git status
On branch feature
Changes to be committed:
  (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)

	new file:   feature.txt

bash-4.3$ git commit -m &#39;init commit&#39;
[feature 4e31b7f] init commit
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 feature.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是真正把这个文件提交到版本库了。这时用&lt;code&gt;git log&lt;/code&gt;是可以查看到的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;commit 4e31b7fca7a95f5fb7a9c0ace9a94e02a9f18eba
Author: lovelock &amp;lt;frostwong@gmail.com&amp;gt;
Date:   Fri May 13 22:54:09 2016 +0800

    init commit
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>为PHP添加全局函数</title>
      <link>http://localhost:1313/php/internals/create-functions/</link>
      <pubDate>Thu, 14 Apr 2016 22:12:56 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/internals/create-functions/</guid>
      <description>

&lt;p&gt;这几天一直没有抽出空来写，都快忘了。&lt;/p&gt;

&lt;p&gt;下面开始写第一个函数。注意这里我说&lt;strong&gt;函数&lt;/strong&gt;而不是&lt;strong&gt;方法&lt;/strong&gt;，是有意要和&lt;strong&gt;类的方法&lt;/strong&gt;做区分。因为这里的&lt;strong&gt;函数&lt;/strong&gt;是全局的。&lt;/p&gt;

&lt;p&gt;不能忘了咱们的功能设计，这里我需要一个这样的名叫&lt;code&gt;format_log&lt;/code&gt;函数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;接收一个字符串，用&lt;code&gt;sprintf&lt;/code&gt;格式化以后传递给&lt;code&gt;str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接收若干个字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先要思考几个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;怎么在PHP的命名空间中注册这个函数？&lt;/li&gt;
&lt;li&gt;怎么接收参数？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;在php命名空间中注册一个函数&#34;&gt;在PHP命名空间中注册一个函数&lt;/h2&gt;

&lt;p&gt;找到这里&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* {{{ hylog_functions[]
 *
 * Every user visible function must have an entry in hylog_functions[].
 */
const zend_function_entry hylog_functions[] = {
    PHP_FE(confirm_hylog_compiled,  NULL)       /* For testing, remove later. */
    PHP_FE_END  /* Must be the last line in hylog_functions[] */
};
/* }}} */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意注释，“所有用户可见的函数都需要在&lt;code&gt;hylog_functions[]&lt;/code&gt;中有一个入口”。所以，我在里面添加一行，变成这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* {{{ hylog_functions[]
 *
 * Every user visible function must have an entry in hylog_functions[].
 */
const zend_function_entry hylog_functions[] = {
    PHP_FE(confirm_hylog_compiled,  NULL)       /* For testing, remove later. */
    PHP_FE(format_log, NULL)
    PHP_FE_END  /* Must be the last line in hylog_functions[] */
};
/* }}} */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先不用管第二个参数&lt;code&gt;NULL&lt;/code&gt;，现在只需要知道它和目标函数要接收的参数有关即可，后面会详细讲述。现在函数&lt;code&gt;format_log&lt;/code&gt;已经注册进了PHP了，但入口又在哪里呢？顺着&lt;code&gt;hylog_functions&lt;/code&gt;找，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* {{{ hylog_module_entry
 */
zend_module_entry hylog_module_entry = {
	STANDARD_MODULE_HEADER,
	&amp;quot;hylog&amp;quot;,
	hylog_functions,
	PHP_MINIT(hylog),
	PHP_MSHUTDOWN(hylog),
	PHP_RINIT(hylog),		/* Replace with NULL if there&#39;s nothing to do at request start */
	PHP_RSHUTDOWN(hylog),	/* Replace with NULL if there&#39;s nothing to do at request end */
	PHP_MINFO(hylog),
	PHP_HYLOG_VERSION,
	STANDARD_MODULE_PROPERTIES
};
/* }}} */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到花括号中的第三个变量。刚才我们说了，所有用户可见的函数需要写在&lt;code&gt;hylog_functions&lt;/code&gt;里，现在又把它打包传给&lt;code&gt;zend_module_entry&lt;/code&gt;类型的变量了。至于后面的几个宏，其中&lt;code&gt;PHP_MINIT&lt;/code&gt;和&lt;code&gt;PHP_MSHUTDOWN&lt;/code&gt;是一对，表示&lt;strong&gt;模块&lt;/strong&gt;的启动和关闭，所谓模块，其实就是扩展了；&lt;code&gt;PHP_RINIT&lt;/code&gt;和&lt;code&gt;PHP_RSHUTDOWN&lt;/code&gt;是一对，表示&lt;strong&gt;请求&lt;/strong&gt;的开始和关闭；&lt;code&gt;PHP_MINFO&lt;/code&gt;用来控制&lt;code&gt;phpinfo()&lt;/code&gt;或&lt;code&gt;php -i&lt;/code&gt;的输出中关于本扩展的信息；&lt;code&gt;PHP_HYLOG_VERSION&lt;/code&gt;就是本扩展的版本号了。这些后面会详述(TODO)。至于&lt;code&gt;STANDARD_MODULE_PROPERTIES&lt;/code&gt;，就是一个内置了宏了，暂时也不用管它。(TODO问问鸟哥）&lt;/p&gt;

&lt;p&gt;那最关键的一步还没做呢，实现该方法。&lt;/p&gt;

&lt;p&gt;PHP为我们提供了一个宏来定义函数，&lt;code&gt;ZEND_FUNCTION&lt;/code&gt;或&lt;code&gt;PHP_FUNCTION&lt;/code&gt;，它两个本质上是一样的，不过既然到现在生成的骨架里面还在用&lt;code&gt;PHP_FUNCTION&lt;/code&gt;，那我们姑且就保持一致吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;PHP_FUNCTION(format_log)
{
	char str[] = &amp;quot;hylog&amp;quot;;
	
	php_printf(&amp;quot;Hello, %s\n&amp;quot;, str);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把它写在和&lt;code&gt;confirm_hylog_compiled&lt;/code&gt;相同的那块区域。现在执行&lt;code&gt;rebuild.sh&lt;/code&gt;，然后&lt;code&gt;php -r &#39;format_log();&lt;/code&gt;应该就能看到&lt;code&gt;Hello, extenstion&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;等等，我们说好的是要接收输入参数的，怎么现在又是一个没有参数的函数？没关系，刚才只是为了验证一下方法是否走的通，现在我们来考虑接收参数。&lt;/p&gt;

&lt;h2 id=&#34;接收参数的函数&#34;&gt;接收参数的函数&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——扩展的骨架</title>
      <link>http://localhost:1313/php/internals/create-skeleton-of-extension/</link>
      <pubDate>Sat, 09 Apr 2016 22:04:18 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/internals/create-skeleton-of-extension/</guid>
      <description>

&lt;p&gt;前面啰嗦了这么多读者都要没有兴趣了。从现在起要真正开始PHP扩展开发阶段了。&lt;/p&gt;

&lt;p&gt;首先来生成扩展的骨架。所谓骨架就是一个扩展需要的基本文件了。&lt;/p&gt;

&lt;h2 id=&#34;获取php源码&#34;&gt;获取PHP源码&lt;/h2&gt;

&lt;p&gt;截至目前，PHP最新源码是7.0.5。&lt;a href=&#34;http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror&#34;&gt;下载链接&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  projects wget http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror -O php705.tar.bz2
--2016-04-09 10:18:39--  http://cn2.php.net/get/php-7.0.5.tar.bz2/from/this/mirror
Resolving cn2.php.net (cn2.php.net)... 202.108.35.194, 202.108.35.235, 202.108.35.237, ...
Connecting to cn2.php.net (cn2.php.net)|202.108.35.194|:80... connected.
HTTP request sent, awaiting response... 302 Found
Location: http://cn2.php.net/distributions/php-7.0.5.tar.bz2 [following]
--2016-04-09 10:18:39--  http://cn2.php.net/distributions/php-7.0.5.tar.bz2
Reusing existing connection to cn2.php.net:80.
HTTP request sent, awaiting response... 200 OK
Length: 14086522 (13M) [application/octet-stream]
Saving to: ‘php705.tar.bz2’

php705.tar.bz2                             100%[=======================================================================================&amp;gt;]  13.43M  4.49MB/s    in 3.0s

2016-04-09 10:18:42 (4.49 MB/s) - ‘php705.tar.bz2’ saved [14086522/14086522]

➜  projects md5sum php705.tar.bz2
b15e6836babcbf0aa446678ee38f896b  php705.tar.bz2
➜  projects echo b15e6836babcbf0aa446678ee38f896b
b15e6836babcbf0aa446678ee38f896b
➜  projects tar xjf php705.tar.bz2
➜  projects cd php-7.0.5/ext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于来到了正题了。我现在也终于明白鸟哥为啥费劲写个生成Yaf最小化应用的脚本了，就是从写扩展的经历中得来的，既然可以帮用户做的更多，那就帮一下好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  ext ./ext_skel --extname=hylog
Creating directory hylog
Creating basic files: config.m4 config.w32 .gitignore hylog.c php_hylog.h CREDITS EXPERIMENTAL tests/001.phpt hylog.php [done].

To use your new extension, you will have to execute the following steps:

1.  $ cd ..
2.  $ vi ext/hylog/config.m4
3.  $ ./buildconf
4.  $ ./configure --[with|enable]-hylog
5.  $ make
6.  $ ./sapi/cli/php -f ext/hylog/hylog.php
7.  $ vi ext/hylog/hylog.c
8.  $ make

Repeat steps 3-6 until you are satisfied with ext/hylog/config.m4 and
step 6 confirms that your module is compiled into PHP. Then, start writing
code and repeat the last two steps as often as necessary.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，&lt;code&gt;ext_skel&lt;/code&gt;就帮我们生成了一个名为&lt;code&gt;hylog&lt;/code&gt;的扩展框架。&lt;/p&gt;

&lt;p&gt;下面要介绍一下安装扩展的两种方式了，一种是直接编译进PHP，一种是接下来我们要讨论的这种，即动态加载的扩展。&lt;/p&gt;

&lt;p&gt;什么是直接编译进PHP呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  ext cd hylog
➜  hylog ls
config.m4  config.w32  CREDITS  EXPERIMENTAL  hylog.c  hylog.php  php_hylog.h  tests
➜  hylog vim config.m4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会看到这样的几行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;dnl If your extension references something external, use with:

dnl PHP_ARG_WITH(hylog, for hylog support,
dnl Make sure that the comment is aligned:
dnl [  --with-hylog             Include hylog support])

dnl Otherwise use enable:

dnl PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
dnl [  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的&lt;code&gt;dnl&lt;/code&gt;是注释，主要看&lt;code&gt;--with-hylog&lt;/code&gt;和&lt;code&gt;--enable-hylog&lt;/code&gt;。假定你来看本文，你一定自己编译过PHP了，如果没有，那先去整一遍再回来看吧：）
是这样的，我们在编译PHP的时候经常会碰到类似这种&lt;code&gt;--with[out]-blah=/path/to/foo&lt;/code&gt;或者&lt;code&gt;--enable-blah&lt;/code&gt;或者&lt;code&gt;--disable-blah&lt;/code&gt;的选项吧。其实对编写扩展的我们来说，这两种都是可行的，并没有本质上的区别，只是一般用&lt;code&gt;--with&lt;/code&gt;会带个路径，告诉PHP这个扩展依赖的外部库的路径，而&lt;code&gt;--enable&lt;/code&gt;则表示该扩展是独立的，或者依赖的库在默认的搜索路径内。&lt;/p&gt;

&lt;p&gt;那和我们说的两种安装方式有什么关系呢？不如我们就来真的安装一下看看效果吧。&lt;/p&gt;

&lt;p&gt;看上面的注释，我们知道了需要把&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;dnl PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
dnl [  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段改成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m4&#34;&gt;PHP_ARG_ENABLE(hylog, whether to enable hylog support,
dnl Make sure that the comment is aligned:
[  --enable-hylog           Enable hylog support])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于是喜欢用&lt;code&gt;--enable&lt;/code&gt;还是喜欢用&lt;code&gt;--with&lt;/code&gt;看个人喜好了，因为本例中并没有用到外部依赖，所以用&lt;code&gt;--enable&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;提醒一下，改完之后最好把当前的这个状态保存下来——创建一个git工作目录就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git init
Initialized empty Git repository in /home/frost/projects/php-7.0.5/ext/hylog/.git/
➜  hylog git:(master) ✗ gst
On branch master

Initial commit

Untracked files:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)

	.gitignore
	CREDITS
	EXPERIMENTAL
	config.m4
	config.w32
	hylog.c
	hylog.php
	php_hylog.h
	tests/

nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)
➜  hylog git:(master) ✗ ga .
➜  hylog git:(master) ✗ gc -m &#39;init hylog&#39;
[master (root-commit) 58e5e4a] init hylog
 Committer: frost &amp;lt;frost@debian.unixera.com&amp;gt;
Your name and email address were configured automatically based
on your username and hostname. Please check that they are accurate.
You can suppress this message by setting them explicitly. Run the
following command and follow the instructions in your editor to edit
your configuration file:

    git config --global --edit

After doing this, you may fix the identity used for this commit with:

    git commit --amend --reset-author

 9 files changed, 409 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 CREDITS
 create mode 100644 EXPERIMENTAL
 create mode 100644 config.m4
 create mode 100644 config.w32
 create mode 100644 hylog.c
 create mode 100644 hylog.php
 create mode 100644 php_hylog.h
 create mode 100644 tests/001.phpt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么要这么做呢？其实主要是想让这个目录干净，因为待会儿执行了一些命令之后会生成很多文件，如果你想清除这些文件就变得很麻烦。但现在我只把这些文件&lt;code&gt;commit&lt;/code&gt;了，待会儿生成文件后，如果我想删除，就可以用&lt;code&gt;git clean -df&lt;/code&gt;，立即回到现在的状态。但关于&lt;code&gt;git&lt;/code&gt;的操作，那就是另外一回事了（强烈推荐&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#34;&gt;廖雪峰的git教程&lt;/a&gt;)。&lt;/p&gt;

&lt;h3 id=&#34;编译进php&#34;&gt;编译进PHP&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;重新生成配置文件&lt;/p&gt;

&lt;p&gt;注意其中的&lt;code&gt;./buildconf --force&lt;/code&gt;，之所以带&lt;code&gt;--force&lt;/code&gt;是因为我们是在正式版的PHP源码中进行操作的，正常情况下使用这种方式编译的都是内建扩展，例如&lt;code&gt;PDO&lt;/code&gt;这种，是PHP官方团队开发的，所以你非要用这种方式编译的话，就强制一下好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git:(master) cd ..
➜  ext cd ..
➜  php-7.0.5 ./buildconf --force
Forcing buildconf
Removing configure caches
buildconf: checking installation...
buildconf: autoconf version 2.69 (ok)
rebuilding aclocal.m4
rebuilding configure
rebuilding main/php_config.h.in
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找变化&lt;/p&gt;

&lt;p&gt;刚刚的操作背后发生了什么呢？注意&lt;code&gt;rebuilding&lt;/code&gt;的三行，那我们就挨个看看。分别在三个文件中搜索&lt;code&gt;hylog&lt;/code&gt;关键字吧。
在&lt;code&gt;aclocal.m4&lt;/code&gt;中未找到变化。
在&lt;code&gt;configure&lt;/code&gt;中有大量变化，稍后介绍能看到的变化。
在&lt;code&gt;main/php_config.h.in&lt;/code&gt;中，增加了两行，用来取消&lt;code&gt;COMPILE_DL_HYLOG&lt;/code&gt;的定义，表示该扩展不是动态加载。&lt;/p&gt;

&lt;p&gt;这时检查一下&lt;code&gt;configure --help&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --help | grep hylog
  --enable-hylog           Enable hylog support
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;诶，有点眼熟对不对？就是刚才在&lt;code&gt;ext/hylog/config.m4&lt;/code&gt;中取消注释的内容。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编译PHP&lt;/p&gt;

&lt;p&gt;既然要把它编译进来，那就加上&lt;code&gt;--enable-hylog&lt;/code&gt;吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --enable-hylog
➜  php-7.0.5 make
➜  php-7.0.5 sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看已安装的扩展&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 php -v
PHP 7.0.5 (cli) (built: Apr  9 2016 11:08:08) ( NTS )
Copyright (c) 1997-2016 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies
➜  php-7.0.5 php -m
[PHP Modules]
Core
ctype
date
dom
fileinfo
filter
hash
hylog
iconv
json
libxml
pcre
PDO
pdo_sqlite
Phar
posix
Reflection
session
SimpleXML
SPL
sqlite3
standard
tokenizer
xml
xmlreader
xmlwriter
    
[Zend Modules]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以看到我们新创建的扩展已经编译进PHP了——虽然它没有任何功能。可以再到&lt;code&gt;/usr/local/lib/php/extensions/no-debug-non-zts-20151012&lt;/code&gt;中验证一下是不是真的没有&lt;code&gt;hylog.so&lt;/code&gt;存在。&lt;/p&gt;

&lt;p&gt;所以如果不想用它了怎么办呢？你当然可以选择无视它，但最好还是卸载了吧，卸载的方法也很简单，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  php-7.0.5 ./configure --disable-hylog
➜  php-7.0.5 make
➜  php-7.0.5 sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来就是三行，其实要用很长时间，所以，像我们这样的第三方扩展开发者还是不要用这种方式比较好。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;动态加载&#34;&gt;动态加载&lt;/h3&gt;

&lt;p&gt;动态加载方式是把每个扩展编译成一个单独的&lt;code&gt;.so&lt;/code&gt;文件，然后在&lt;code&gt;php.ini&lt;/code&gt;中加上&lt;code&gt;extension=hylog.so&lt;/code&gt;，如果有配置就再加上一些配置。CLI的话就直接生效了，FPM环境下就要重启一下FPM了。我们这里只讨论CLI模式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第三方扩展安装的一般流程&lt;/p&gt;

&lt;p&gt;还记得我刚刚提到的执行某些命令后会生成很多文件吗？就是这里了。如果你还没有用&lt;code&gt;git&lt;/code&gt;，我劝你现在用了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;➜  hylog git:(master) phpize
Configuring for:
PHP Api Version:         20151012
Zend Module Api No:      20151012
Zend Extension Api No:   320151012
➜  hylog git:(master) ✗ ./configure
➜  hylog git:(master) ✗ make
➜  hylog git:(master) ✗ sudo make install
Installing shared extensions:     /usr/local/lib/php/extensions/no-debug-non-zts-20151012/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好，到这里已经看到在独立编译动态扩展时，生成的&lt;code&gt;.so&lt;/code&gt;文件是放在了这个目录下的。这时动态的好处就体现出来了。文件有了，至于你想不想用，只需要修改&lt;code&gt;php.ini&lt;/code&gt;即可，不用任何重新编译。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装和卸载扩展&lt;/p&gt;

&lt;p&gt;前面说了，如果需要该扩展，编辑&lt;code&gt;/usr/local/lib/php.ini&lt;/code&gt;，在最下面添加（安装）或删除（卸载）一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;extension=hylog.so
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调试&lt;/p&gt;

&lt;p&gt;我可不敢保证代码一次就能成功，调试的时候要多次执行以上三个命令，所以可以创建一个&lt;code&gt;rebuild.sh&lt;/code&gt;脚本，运行脚本重新编译并安装最新的版本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./configure
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最好把它加入到&lt;code&gt;git&lt;/code&gt;工作目录中。&lt;/p&gt;

&lt;p&gt;扩展的安装就这些，下一节介绍PHP变量的基本类型。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——用PHP实现类的原型</title>
      <link>http://localhost:1313/php/internals/class-prototype-in-php/</link>
      <pubDate>Sat, 09 Apr 2016 21:55:00 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/internals/class-prototype-in-php/</guid>
      <description>&lt;p&gt;在编写之前先用PHP实现这个类的原型吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

namespace Hylog;

use \DateTime;

class Hylog
{
    const HYLOG_VERSION = &amp;quot;0.1.0&amp;quot;;

    const EMERGENCY = &#39;EMERGENCY&#39;;
    const ALERT     = &#39;ALERT&#39;;
    const CRITICAL  = &#39;CRITICAL&#39;;
    const ERROR     = &#39;ERROR&#39;;
    const WARNING   = &#39;WARNING&#39;;
    const NOTICE    = &#39;NOTICE&#39;;
    const INFO      = &#39;INFO&#39;;
    const DEBUG     = &#39;DEBUG&#39;;

    private static $_instance;

    private $_basePath;
    private $_sliceLogByHour;

    public function log($level, $message, $context = array())
    {
        $line = $this-&amp;gt;interpolate($message, $context);

        $datetime         = new DateTime();
        $timestamp        = $datetime-&amp;gt;getTimestamp();
        $formatedDatetime = $datetime-&amp;gt;format(DateTime::ATOM);

        $line = $timestamp . &amp;quot;\t|\t&amp;quot; . $formatedDatetime . &amp;quot;\t|\t&amp;quot; . $line;

        $this-&amp;gt;output($level, $line);
    }

    public function emergency($message, $context = array())
    {
        $this-&amp;gt;log(self::EMERGENCY, $message, $context);
    }

    public function alert($message, $context = array())
    {
        $this-&amp;gt;log(self::ALERT, $message, $context);
    }

    public function critical($message, $context = array())
    {
        $this-&amp;gt;log(self::CRITICAL, $message, $context);
    }

    public function error($message, $context = array())
    {
        $this-&amp;gt;log(self::ERROR, $message, $context);
    }

    public function warning($message, $context = array())
    {
        $this-&amp;gt;log(self::WARING, $message, $context);
    }

    public function notice($message, $context = array())
    {
        $this-&amp;gt;log(self::NOTICE, $message, $context);
    }

    public function info($message, $context = array())
    {
        $this-&amp;gt;log(self::INFO, $message, $context);
    }

    public function debug($message, $context = array())
    {
        $this-&amp;gt;log(self::DEBUG, $message, $context);
    }

    public static function getInstance() : object
    {
        if (!isset(self::$_instance)) {
            self::$_instance = new static();
        }

        return self::$_instance;
    }

    public function getVersion()
    {
        return self::HYLOG_VERSION;
    }

    public function setBasePath($path)
    {
        $this-&amp;gt;_basePath = $path;
    }

    public function getBasePath() : string
    {
        return $this-&amp;gt;_basePath;
    }

    public function setSliceByHour($bool)
    {
        $this-&amp;gt;_sliceLogByHour = $bool;
    }

    public function getSliceByHour() : bool
    {
        return $this-&amp;gt;_sliceLogByHour;
    }

    private function output($level, $message)
    {
        $logFile = $this-&amp;gt;getLogFile($level);

        error_log($message . PHP_EOL, 3, $logFile);
    }

    private function getLogFile($level) : string
    {
        $cHour = date(&#39;ymdH&#39;);
        $cDay  = date(&#39;ymd&#39;);

        if ($this-&amp;gt;_sliceLogByHour) {
            return $this-&amp;gt;_basePath . &#39;/&#39; . $level . &#39;.&#39; . $cHour . &#39;.log&#39;;
        } else {
            return $this-&amp;gt;_basePath . &#39;/&#39; . $level . &#39;.&#39; . $cDay . &#39;.log&#39;;
        }
    }

    private function interpolate($message, $context = array())
    {
        foreach ($context as $key =&amp;gt; $val) {
            $replace[&#39;{&#39; . $key . &#39;}&#39;] = $val;
        }

        return strtr($message, $replace);
    }

    private function __construct()
    {
        $this-&amp;gt;_basePath = &#39;/tmp/log&#39;;

        if (!is_dir($this-&amp;gt;_basePath)) {
            mkdir($this-&amp;gt;_basePath, 0700, true);
        } else {
            chmod($this-&amp;gt;_basePath, 0700);
        }

        $this-&amp;gt;_sliceLogByHour = true;
    }

    private function __clone()
    {
    }

    private function __wakeup()
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——目标和计划</title>
      <link>http://localhost:1313/php/internals/schedules/</link>
      <pubDate>Sat, 09 Apr 2016 21:13:28 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/internals/schedules/</guid>
      <description>

&lt;p&gt;好了，现在来整理一下我们要做的工作。&lt;/p&gt;

&lt;h2 id=&#34;功能目标&#34;&gt;功能目标&lt;/h2&gt;

&lt;p&gt;既然是要做一个记日志的扩展，那当然就避免不了两个功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;格式化日志流&lt;/li&gt;
&lt;li&gt;将日志流推送到特定目标（通常是写入文件）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个是最核心的功能，其他的都是辅助。但辅助也可以很贴心，所以我设计了以下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;尽可能多的从扩展层面获取共用的信息，比如时间、客户端IP、当前机器的IP等（这里涉及&lt;strong&gt;超全局变量&lt;/strong&gt;的获取）&lt;/li&gt;
&lt;li&gt;设计尽量简单的默认规则，既可以开箱即用，又可以随心配置&lt;/li&gt;
&lt;li&gt;遵守&lt;a href=&#34;http://www.php-fig.org/psr/psr-3/&#34;&gt;PSR-3&lt;/a&gt;规范&lt;/li&gt;
&lt;li&gt;命名空间和传统写法的兼容(鸟哥的Yaf是教科书）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一个需要考虑的问题是高并发场景下的文件写入丢失问题，我觉得以我目前的水平是无法解决这个问题的，那没关系，PHP内置的已经有强大的&lt;code&gt;error_log&lt;/code&gt;方法了，它可以保证这点，用它就可以。喂等等，那既然已经有了&lt;code&gt;error_log&lt;/code&gt;，我干嘛还要做这个呢？&lt;/p&gt;

&lt;p&gt;因为它不够灵活。&lt;/p&gt;

&lt;p&gt;我们通常的做法是封装&lt;code&gt;error_log&lt;/code&gt;方法，填充默认参数、格式化、写入文件等，&lt;code&gt;error_log&lt;/code&gt;方法本身是很快的，但挡不住我们添加的这些代码的消耗也很大，因为写日志是个非常频繁的操作，所以一个极小的性能损失积累下来都可能影响很大。&lt;/p&gt;

&lt;h2 id=&#34;取名&#34;&gt;取名&lt;/h2&gt;

&lt;p&gt;既然用C写，那就是奔着高性能去的，High Performance PHP Log，叫Hilog貌似就可以，但为了致敬鸟哥，把i换成y好了：）所以叫Hylog。&lt;/p&gt;

&lt;h2 id=&#34;类的设计&#34;&gt;类的设计&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;拥有PRS-3规定的8个level作为常量&lt;/li&gt;
&lt;li&gt;对应8个方法，分别写到不同的文件&lt;/li&gt;
&lt;li&gt;一个log方法比上述8个方法多个level参数，上述8个函数实际是调用这个方法记日志的&lt;/li&gt;
&lt;li&gt;格式化日志的方法&lt;/li&gt;
&lt;li&gt;数组插值的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;依赖关系&#34;&gt;依赖关系&lt;/h2&gt;

&lt;p&gt;依赖PHP内置函数&lt;code&gt;error_log&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用PHP生成器和迭代器</title>
      <link>http://localhost:1313/php/php-generator-and-iterator/</link>
      <pubDate>Tue, 05 Apr 2016 12:05:46 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/php-generator-and-iterator/</guid>
      <description>

&lt;p&gt;从开始写PHP就知道迭代器这个东西，当时师傅告诉我用的挺少的，需要的时候再看也不晚，于是就没有放在意上。但他还说这其实也是区分高手和菜鸟的一个标志，那我还是研究一下好了：）&lt;/p&gt;

&lt;p&gt;PHP程序员都知道我们最经常用的可能就是&lt;code&gt;foreach&lt;/code&gt;这个大杀器了。得益于我们&lt;strong&gt;万能的数组&lt;/strong&gt;，所以这个大杀器在多数场合都是可以直接用的，只要输入元素是数组类型即可——事实上并不是如此，&lt;code&gt;foreach&lt;/code&gt;能遍历数组并不是因为它是数组，而是因为数组&lt;code&gt;implements&lt;/code&gt;了&lt;code&gt;Iterator&lt;/code&gt;接口。说白了就是只要告诉&lt;code&gt;foreach&lt;/code&gt;遍历的规则，它就可以执行遍历，而和是否数组无关。&lt;/p&gt;

&lt;h3 id=&#34;iterator&#34;&gt;Iterator&lt;/h3&gt;

&lt;h4 id=&#34;解析&#34;&gt;解析&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt;接口定义了5个方法，如果一个类要实现&lt;code&gt;Iterator&lt;/code&gt;接口，当然就要实现这一套方法了。&lt;code&gt;Iterator&lt;/code&gt;的原型如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;Interface Iterator
{
	abstract public function current() : mixed;
	abstract public function key() : scalar;
	abstract public function next() : void;
	abstract public function rewind() : void;
	abstract public function valid() : boolean;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;我在方法后面按照PHP7的新语法加了个返回值类型，其实这样写是不对的，但可以表明意思啦：）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;详细说一下这几个方法要做的事情。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;current()&lt;/p&gt;

&lt;p&gt;返回当前位置的&lt;strong&gt;值&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;key()&lt;/p&gt;

&lt;p&gt;返回当前位置的&lt;strong&gt;键&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;next()&lt;/p&gt;

&lt;p&gt;当前位置的&lt;strong&gt;键&lt;/strong&gt;加1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rewind()&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;键&lt;/strong&gt;回到第一个位置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;valid()&lt;/p&gt;

&lt;p&gt;返回当前的&lt;strong&gt;键&lt;/strong&gt;是否是有意义的。如是否是&lt;code&gt;false&lt;/code&gt;/&lt;code&gt;NULL&lt;/code&gt;等。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;实例&#34;&gt;实例&lt;/h4&gt;

&lt;p&gt;还是来具体写个例子理解一下吧。通常写这种例子的作者都会举一个类，它的一个属性是个数组，然后实现&lt;code&gt;Iterator&lt;/code&gt;的5个方法，来让这个类可以使用&lt;code&gt;foreach&lt;/code&gt;，这个例子没意思，因为数组本身就带&lt;code&gt;current&lt;/code&gt;、&lt;code&gt;key&lt;/code&gt;这些方法。让我来举一个&lt;code&gt;pdo_mysql&lt;/code&gt;从数据库中取数据的例子吧。&lt;/p&gt;

&lt;p&gt;从数据库取出一一个数组，数组中的元素是&lt;code&gt;User&lt;/code&gt;类的实例，我们需要&lt;code&gt;Users&lt;/code&gt;类的方法，它又要有一些方法。所以，就产生了这样的用法了。这个例子可能有些牵强，但起码描述了一个使用场景，比单纯的迭代一个类的类型为数组的属性要有意义。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://git.coding.net/lovelock/iterator_example.git&#34;&gt;代码地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;generator&#34;&gt;Generator&lt;/h3&gt;

&lt;p&gt;只有真正理解了&lt;code&gt;Iterator&lt;/code&gt;才能再来谈&lt;code&gt;Generator&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;还是举例来说，前面已经说了一个比较复杂的例子，这里为了说明二者的区别，举个简单的例子。&lt;/p&gt;

&lt;p&gt;假定有一个日志文件，1000000行吧，很大了？或许吧。现在我们要遍历这个文件，找到我们需要的东西。如果使用&lt;code&gt;Iterator&lt;/code&gt;，可能需要这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

class LinesIterator implements Iterator
{
	private $_fp;
	private $_currentLine;
	private $_lineNum;

	public function __construct($filename)
	{
		$this-&amp;gt;_fp = fopen($filename, &#39;r&#39;);
		$this-&amp;gt;_lineNum = 0;
	}

	public function current()
	{
		$this-&amp;gt;_currentLine = fgets($this-&amp;gt;_fp);
		return $this-&amp;gt;_currentLine;
	}

	public function key()
	{
		return $this-&amp;gt;_lineNum;
	}

	public function valid()
	{
		return $this-&amp;gt;_currentLine === false;
	}

	public function next()
	{
		fgets($this-&amp;gt;_fp);
		$this-&amp;gt;_lineNum++;
	}

	public function rewind()
	{
	}

	public function __destruct()
	{
		fclose($this-&amp;gt;_fp);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要遍历文件时，可以这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$file = new LinesIterator(&#39;file&#39;);

foreach ($file-&amp;gt;current() as $line) {
	echo $line;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这没有问题，但也太复杂了吧！！！重点是即使我实现了这些，但还是无法随便定位到某一行（这需要&lt;code&gt;fseek&lt;/code&gt;）。所以这种场景下，&lt;code&gt;Generator&lt;/code&gt;出现了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function getLine($fileName)
{
	$fp = fopen($fileName, &#39;r&#39;);	

	while ($line = fgets($fp) !== false) {
		yield $line;
	}

	fclose($fp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就简明多了。&lt;code&gt;Generator&lt;/code&gt;的标志就是&lt;code&gt;yield&lt;/code&gt;，这点在所有编程语言里都一样。&lt;/p&gt;

&lt;p&gt;正常如果在用&lt;code&gt;yield&lt;/code&gt;的地方用了&lt;code&gt;return&lt;/code&gt;，那么代码执行到这里就结束了，下次再执行这个函数时，还是从头开始，我们永远得不到文件的第二行。那么怎么办呢？我的理解是&lt;code&gt;Generator&lt;/code&gt;把这行内容返回的同时，也把文件句柄所在的指针向后移动了一个单位，下次再次执行该函数时，就会从上次的位置继续执行。&lt;/p&gt;

&lt;p&gt;这个函数的功能和上面那个类的效果完全相同。&lt;/p&gt;

&lt;p&gt;还有一点要提一下，&lt;code&gt;Generator&lt;/code&gt;通常用来处理文件特别大的情况，比如上面这样，文件太大，如果直接用&lt;code&gt;file&lt;/code&gt;读进来保存成为一个数组，很可能就会报错。而如果用&lt;code&gt;Generator&lt;/code&gt;就没有这个问题了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP扩展实战——背景介绍</title>
      <link>http://localhost:1313/php/internals/introduction/</link>
      <pubDate>Mon, 04 Apr 2016 22:37:18 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/internals/introduction/</guid>
      <description>

&lt;p&gt;这段时间其实在看C语言，但看来看去也不知道学了这些知识用在哪里。作为一名PHP程序员，想要进阶，当然得懂PHP的运行原理。那么，编写扩展就成了认识PHP的必经之路。而PHP的扩展当然是用C写的，这样，也给自己刚刚学的C语言找到了练手的项目。&lt;/p&gt;

&lt;p&gt;那么写个什么项目好呢？最好简单一些，但也要能涵盖编写一个完整功能的扩展的方方面面。忘了在哪里看到了&lt;a href=&#34;https://github.com/Neeke/SeasLog&#34;&gt;SeasLog&lt;/a&gt;，感觉这个项目很符合我的期望，于是上它的issue列表里面找到了一个功能请求，作者还没有着手做，那我就顺手帮忙做了吧，前几天已经被作者合并了，让我的信心也倍增。所以，我决定自己也再写一个类似的东西，主要目的是通过做一个完整的项目，各个击破PHP扩展编写过程中的所有问题。&lt;/p&gt;

&lt;p&gt;言归正传，先列上参考文献列表好了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.phpinternalsbook.com/&#34;&gt;PHP internals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/walu/phpbook&#34;&gt;PHP扩展开发及内核应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://php.net/manual/en/internals2.php&#34;&gt;PHP at the core: A Hacker&amp;rsquo;s Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/laruence/yaf&#34;&gt;Yaf源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.php.net/downloads.php&#34;&gt;PHP源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/laruence/php7-internal&#34;&gt;Understanding PHP7 Internal articles&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;声明&#34;&gt;声明：&lt;/h2&gt;

&lt;p&gt;本系列所描述的PHP扩展相关知识大部分基于PHP 7.0.x，与PHP 5.x不完全兼容，因为列表里的前三个文献都是讲PHP5的，所以我在编写本文时也碰到了不少兼容性问题，都是通过看Yaf源码和PHP源码搞定兼容性的，我没有提到的地方还请在留言中指出。我当然也希望我的这份绵薄之力能帮助弥补目前PHP7相关文档严重不足的情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>seaslog 和 error_log性能大比拼</title>
      <link>http://localhost:1313/php/log-bench/</link>
      <pubDate>Fri, 01 Apr 2016 16:33:19 +0800</pubDate>
      <author>frostwong@gmail.com (Frost Wong)</author>
      <guid>http://localhost:1313/php/log-bench/</guid>
      <description>

&lt;p&gt;今天花了点时间测试了开源项目&lt;a href=&#34;http://neeke.github.io/SeasLog/&#34;&gt;seaslog&lt;/a&gt;和PHP内置的error_log的性能。本文不涉及该扩展的安装和使用，如果对其不了解，可移步&lt;a href=&#34;http://neeke.github.io/SeasLog/&#34;&gt;官网&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;项目的描述有语法问题&amp;rdquo;A effective &amp;hellip;&amp;ldquo;，我提醒了原作者，然而并没有被理会。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;测试环境&#34;&gt;测试环境&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;Intel&amp;reg; Xeon&amp;reg; CPU  E5520  @ 2.27GHz 8核&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;48G&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;td&gt;7.0.1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Nginx&lt;/td&gt;
&lt;td&gt;1.2.7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;测试代码&#34;&gt;测试代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

error_log(&amp;quot;I am testing performance of error_log&amp;quot; . PHP_EOL, 3, __DIR__ . &#39;/error_log.log&#39;);
SeasLog::debug(&amp;quot;I am testing performance of seaslog&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果数据&#34;&gt;结果数据&lt;/h2&gt;

&lt;p&gt;每种方式测试5次，请求次数1000次，并发量分别是1, 10, 100, 1000。分别记录每次测试的QPS。&lt;/p&gt;

&lt;p&gt;1. error_log&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;并发量&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2430&lt;/td&gt;
&lt;td&gt;2579&lt;/td&gt;
&lt;td&gt;2685&lt;/td&gt;
&lt;td&gt;2484&lt;/td&gt;
&lt;td&gt;2622&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;7303&lt;/td&gt;
&lt;td&gt;7844&lt;/td&gt;
&lt;td&gt;5892&lt;/td&gt;
&lt;td&gt;11739&lt;/td&gt;
&lt;td&gt;9002&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;11763&lt;/td&gt;
&lt;td&gt;6107&lt;/td&gt;
&lt;td&gt;6921&lt;/td&gt;
&lt;td&gt;9258&lt;/td&gt;
&lt;td&gt;11999&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;891&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;889&lt;/td&gt;
&lt;td&gt;883&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2. seaslog&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;并发量&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2147&lt;/td&gt;
&lt;td&gt;2071&lt;/td&gt;
&lt;td&gt;2130&lt;/td&gt;
&lt;td&gt;2123&lt;/td&gt;
&lt;td&gt;2039&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;7415&lt;/td&gt;
&lt;td&gt;9438&lt;/td&gt;
&lt;td&gt;6901&lt;/td&gt;
&lt;td&gt;6445&lt;/td&gt;
&lt;td&gt;6047&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;7770&lt;/td&gt;
&lt;td&gt;9389&lt;/td&gt;
&lt;td&gt;6852&lt;/td&gt;
&lt;td&gt;5806&lt;/td&gt;
&lt;td&gt;6483&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;890&lt;/td&gt;
&lt;td&gt;324&lt;/td&gt;
&lt;td&gt;891&lt;/td&gt;
&lt;td&gt;760&lt;/td&gt;
&lt;td&gt;322&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;测试结果图&#34;&gt;测试结果图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/errorlog.png&#34; alt=&#34;error_log性能测试结果&#34; /&gt;
&lt;img src=&#34;http://7xn2pe.com1.z0.glb.clouddn.com/seaslog.png&#34; alt=&#34;seaslog性能测试结果&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;error_log的性能总体优于seaslog，但并没有压倒性优势&lt;/li&gt;
&lt;li&gt;在并发较高时二者都出现急剧性能下降，程度相当。怀疑瓶颈已经不在写日志，而在Nginx的处理能力了（待验证）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;seaslog使用起来更简单，不需要多层封装&lt;/li&gt;
&lt;li&gt;error_log输出的格式比较单一，如果要加上日期、IP等信息，一定会引入很多PHP函数调用，导致性能损失。但seaslog在这方面就有很大的想象空间，在扩展中计算时间、获取IP、详细的debug信息都是可能的。不过现在并没有加入这些功能。&lt;/li&gt;
&lt;li&gt;seaslog提供了类似PDO的插值方式，使用起来更方便&lt;/li&gt;
&lt;li&gt;seaslog可以自定义配置多&lt;/li&gt;
&lt;li&gt;一个细节，error_log在type=3时并没有在message后面加上换行符，需要自行添加，也就是说每次都要有一个字符串拼接，这在seaslog中得到了改进&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我之前看到有人说seaslog的日期格式太固定，因此我fork了一份代码加上了配置日期格式的功能，作者到现在都没有合并进主干呢。而且我觉得现在这个功能有些简陋，比如我前面说的第2点，请求的一些基本信息如果从扩展层面直接取到，就不需要再在外层调用PHP函数或通过超全局变量获取了，既简化了外层使用的方式，又提高性能。但作者貌似也没有继续增加功能的意思，可能作者并不想在扩展层面做太复杂的事情，要保持这个项目的简单、纯粹。&lt;/p&gt;

&lt;p&gt;我还是自己再维护一份好了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
